// Calculate last process timestamp if first time only.
const calculateLastProcessTimestamp = (data) => {
    let lastProcessedTimestamp = data.lastProcessedTimestamp;
    if (lastProcessedTimestamp === 0) {
        if (data.historyData !== null && data.historyData.length > 0) {
            lastProcessedTimestamp = Math.floor(parseInt(data.historyData[0].timestamp, 10) / data.intervalSendDataRate);
            lastProcessedTimestamp = lastProcessedTimestamp * data.intervalSendDataRate;
            lastProcessedTimestamp = lastProcessedTimestamp - 1; // Fix for first time only.
        }
    }
    return lastProcessedTimestamp;
};


minifyCandlestick
unminifyCandlestick

30:45

latest

module.exports = {
    initSocket: initSocket,
    createDataToSend: createDataToSend,
    createSendDataInterval: createSendDataInterval
};    


app.set('intervalId', null); // Will hold the id of the sending data to client interval.
    app.set('intervalStartCreateTimestamp', 0); // Milliseconds timestamp of the first data created.
    app.set('intervalSendDataRate', 10); // Interval of sending data in seconds.

module.exports = {
    initDataCreator: initDataCreator,
    reCalculateCandlesticks: reCalculateCandlesticks
};

1543562589
1543562579


0509649576


1543563026
1543563019


// Calculate the relevant data and return new candlestick data to display.
export const createCandleStick = (data) => {
    // Get open and close indexes to slice from array of data.
    let openIndex = data.dataArray.findIndex(i => i.unix === data.currentOpenTime.unix());
    let closeIndex = data.dataArray.findIndex(i => i.unix === data.currentCloseTime.unix());

low, open, close, max

1543430530
1543430530
154343053
154343053
1543430530
1543430529

1543404824
1543404815030

1543407310
1543407193030

1543410433
1543410418030   


 // Get the data of open & close points.
    const openPoint = data.dataArray[openIndex];
    const closePoint = data.dataArray[closeIndex];

    // Slice the relevant data into an array.
    const periodArray = data.dataArray.slice(openIndex, closeIndex);

    // Get the high & low arrays from the relevant data.
    const high = Math.max([...periodArray.map(n => n.high)]);
    const low = Math.min([...periodArray.map(n => n.low)]);

    // Return the calculated 4 parameters from the relevant period array.
    return {
        time: moment.format('HH:mm:ss'),
        open: openPoint.open,
        high: high,
        low: low,
        close: closePoint.close
    };
};

https://canvasjs.com/data/gallery/react/microsoft-stock-price.json
https://canvasjs.com/react-charts/candlestick-chart-json-data-ajax/
https://canvasjs.com/docs/charts/chart-options/axisx/valueformatstring/   


 "form_page_title": "Jones Form",
    "form_page_form_title": "Jones Form",
    "form_page_text_button": "Submit",
    "form_page_first_name_placeholder": "Your first name",
    "form_page_first_name": "First name",
    "form_page_last_name_placeholder": "Your last name",
    "form_page_last_name": "Last name",
    "form_page_email_placeholder": "Your email",
    "form_page_email": "Email",
    "form_page_phone_placeholder": "Your phone number",
    "form_page_phone": "Phone",
    "form_page_error_empty_firstName": "Please enter your first name",
    "form_page_error_invalid_firstName": "Invalid first name. Must enter English characters only",
    "form_page_error_minimum_length_firstName": "Invalid first name. Must include more than 2 characters",
    "form_page_error_empty_lastName": "Please enter your last name",
    "form_page_error_invalid_lastName": "Invalid last name. Must enter English characters only",
    "form_page_error_minimum_length_lastName": "Invalid last name. Must include more than 2 characters",
    "form_page_error_empty_email": "Please enter your email address",
    "form_page_error_invalid_email": "Invalid email address",
    "form_page_error_empty_phone": "Please enter your phone number",
    "form_page_error_invalid_phone": "Invalid phone number. Must enter digit characters only",
    "form_page_error_invalid_length_phone": "Invalid phone number. Must include exactly 10 characters",
    "form_page_error_general": "Oppss.. General error occurred, please try again later :(",
    "error_general": "General error occurred, please try again later :(",
    "error_missing": "Missing #params# parameter(s)",
    "error_invalid": "Invalid #params# parameter(s)",
    "error_not_found": "#param# not found",
    "loader_alternative_text": "Loading..."


http://localhost:3000/api/photosAPI/getPhotosPager?pageNumber=1&count=50

http://localhost:3000/api/photosAPI/getPhotosPager?pageNumber=1&count=10                   


 <div className="order0 table-cell table-cell--head">
                            <h3>Id</h3>
                        </div>
                        <div className="order0 table-cell table-cell--head">
                            <h3>Title</h3>
                        </div>
                        <div className="order0 table-cell table-cell--head">
                            <h3>Album Id</h3>
                        </div>
                        <div className="order0 table-cell table-cell--head">
                            <h3>Url</h3>
                        </div>
                        <div className="order0 table-cell table-cell--head">
                            <h3>Thumb</h3>
                        </div>   

 "albumId": 1,
    "id": 1,
    "title": "accusamus beatae ad facilis cum similique qui sunt",
    "url": "https://via.placeholder.com/600/92c952",
    "thumbnailUrl": "https://via.placeholder.com/150/92c952"

{
    "PORT_EXPRESS_SERVER": "3000",
    "PORT_WEBSOCKET_SERVER": "4000"
}

id":"898932","position":"IT Technician","monthlySalary":10000
"users":[{"id":"898932","name":"USER_78"}

id":"4fede17c312f912796000034","cover_url":null,"description":null,"rating":6.3,"title":"L'affaire Gordji, histoire d'une cohabitation"}

    "eslint": "^5.1.0",
    "express": "^4.16.3",
    "express-async-errors": "^3.0.0",
    "moment": "^2.22.2",
    "winston": "^2.4.0"



Full stack developer - Bitmain
Senior Full Stack Developer - DAV
Front End Engineer - Insert- Pendo
Job title: Sr. Full Stack developer / web Backend developer- PROGGIO
JS Expert- CLOUDINARY



https://www.reddit.com/r/angularjs/comments/5vz3kv/does_anyone_have_good_angular1_with_webpack/
https://github.com/emartech/angular-phonecat-components
https://github.com/orizens/echoes
https://github.com/lucaseverett/heroes-ng1/
https://github.com/emartech/angular-phonecat-components

החלפת נורה.

static int func(String s, char a, char b)
{
if (s.isEmpty()) return -1;

char[] strArray = string.toCharArray();

int i=0;
int aIndex=0;
int bIndex=0;
while (aIndex=0 && bIndex==0 && i<strArray.length)
{
if (strArray[i] == a)
aIndex=i;
if (strArray[i] == b)
bIndex=i;
i++;
}
if (aIndex != 0)
{
if (bIndex == 0)
return aIndex;
else
return Math.min(a, b);
}
else
{
if (bIndex != 0)
return bIndex;
else
return -1;
}
}

הפתרון:
static int func(String s, char a, char b)
{
for (int i = 0; i < s.length(); ++i)
{
char ch = s.charAt(i);
if (ch == a || ch == b)
return i;
}

return -1;
}

CREATE TABLE employees (
    employee_id   NUMERIC       NOT NULL,
    first_name    VARCHAR(1000) NOT NULL,
    last_name     VARCHAR(900)  NOT NULL,
    date_of_birth DATE                   ,
    phone_number  VARCHAR(1000) NOT NULL,
    junk          CHAR(255)             ,
    CONSTRAINT employees_pk
       PRIMARY KEY NONCLUSTERED (employee_id)
);
GO
IF OBJECT_ID('rand_helper') IS NOT NULL
   DROP VIEW rand_helper;
GO

CREATE VIEW rand_helper AS SELECT RND=RAND();
GO
IF OBJECT_ID('random_string') IS NOT NULL
   DROP FUNCTION random_string;
GO

CREATE FUNCTION random_string (@maxlen int)
   RETURNS VARCHAR(255)
AS BEGIN
   DECLARE @rv VARCHAR(255)
   DECLARE @loop int
   DECLARE @len int

   SET @len = (SELECT CAST(rnd * (@maxlen-3) AS INT) + 3
                 FROM rand_helper)
   SET @rv = ''
   SET @loop = 0

   WHILE @loop < @len BEGIN
      SET @rv = @rv 
              + CHAR(CAST((SELECT rnd * 26
                             FROM rand_helper) AS INT )+97)
      IF @loop = 0 BEGIN
          SET @rv = UPPER(@rv)
      END
      SET @loop = @loop +1;
   END

   RETURN @rv
END
GO
IF OBJECT_ID('random_date') IS NOT NULL
   DROP FUNCTION random_date;
GO

CREATE FUNCTION random_date (@mindays int, @maxdays int) 
   RETURNS VARCHAR(255)
AS BEGIN
   DECLARE @rv date
   SET @rv = (SELECT GetDate() 
                   - rnd * (@maxdays-@mindays)
                   - @mindays
                FROM rand_helper)
   RETURN @rv
END
GO
IF OBJECT_ID('random_int') IS NOT NULL
   DROP FUNCTION random_int;
GO

CREATE FUNCTION random_int (@min int, @max int)
   RETURNS INT
AS BEGIN
   DECLARE @rv INT
   SET @rv = (SELECT rnd * (@max) + @min
                FROM rand_helper)
   RETURN @rv
END
GO
WITH generator (n) AS
( SELECT 1
   UNION ALL
  SELECT n + 1 FROM generator
WHERE n < 200
)
INSERT INTO employees (employee_id
                     , first_name, last_name
                     , date_of_birth, phone_number, junk)
select n employee_id
     , [dbo].random_string(11) first_name
     , [dbo].random_string(11) last_name  
     , [dbo].random_date(20*365, 60*365) dob
     , 'N/A' phone
     , 'junk' junk
  from generator
OPTION (MAXRECURSION 200)
GO
UPDATE employees 
   SET first_name='Markus', 
       last_name='Winand'
 WHERE employee_id=123;

exec sp_updatestats;
GO

Redux Thunk / Saga

babel-eslint

Convert pdf to word:
https://docs.zone/pdf-to-word

git commit -m 'init burger-builder' --date="Web Sep 8 14:00 2018 +0100"
https://github.com/orassayag/burger-builder

Car shop order - Test solved in job interview using ASP.NET MVC + jQuery + Angular 1.5
git commit -m 'init burger-builder' --date="Web Sep 8 14:00 2018 +0100"

https://github.com/orassayag/papaito-old

https://github.com/orassayag/dev-test-mvc-angular-car-shop

https://github.com/orassayag/node-vidly-deployment

Google, Ask.com, AOL search, Walla search, BING, Yahoo

https://linkedin.com/in/nivmorabin


public static void main(String[] args) {

LinkedList<Integer> list1 = new LinkedList<Integer>();

LinkedList<Integer> list2 = new LinkedList<Integer>();

list1.add(1);

list1.add(2);

list1.add(3);

list1.add(4);

list1.add(25);

list1.add(34);

list1.add(43);

list1.add(5);

list2.add(-1);

list2.add(-2);

list2.add(-3);

list2.add(4);

list2.add(62);

list2.add(73);

list2.add(4);

list2.add(67);

Iterator<Integer> iter1 = list1.iterator();

Iterator<Integer> iter2 = list2.iterator();

while(iter1.hasNext() ){

while(iter2.hasNext()){

if(iter1.next() == iter2.next())

System.out.println(true);

}

}


bcrypt (For decrypting token), compression (Compress all the project data), eslint (Linting for etter code), express (Rest calls and server CRUD management), fawn (2 face transaction), helmet (Secure the data), jsonwebtoken (Generate user authentication tokens), moment (Manager date times), mongoose (NoSQL BigData Database), winston (For logging into external log files), winston-mongodb (For logging into mongodb itself).
Also, using 'jest' and 'supertest' for both unit and integration tests.
  

עציץ
חלב
להוסיף בקורות חיים ובלינקדאין Problem solver
לעדכן Email searcher בדיסק און קיי
להעביר גם את הCarDevTest
לסמך במסמך Final project.

npm i autoprefixer@latest --save

npm update browser-sync

  "dependencies": {
    "autoprefixer": "^9.2.1",
    "axios": "^0.18.0",
    "babel-core": "6.26.0",
    "babel-eslint": "7.2.3",
    "babel-jest": "20.0.3",
    "babel-loader": "7.1.2",
    "babel-polyfill": "^6.26.0",
    "babel-preset-react-app": "^3.1.1",
    "babel-runtime": "6.26.0",
    "case-sensitive-paths-webpack-plugin": "2.1.1",
    "chalk": "1.1.3",
    "dotenv": "4.0.0",
    "dotenv-expand": "4.2.0",
    "extract-text-webpack-plugin": "3.0.2",
    "file-loader": "1.1.5",
    "fs-extra": "3.0.1",
    "html-webpack-plugin": "2.29.0",
    "moment": "^2.22.2",
    "object-assign": "4.1.1",
    "postcss-flexbugs-fixes": "3.2.0",
    "postcss-loader": "2.0.8",
    "promise": "8.0.1",
    "prop-types": "^15.6.2",
    "raf": "3.4.0",
    "react": "^16.4.2",
    "react-addons-css-transition-group": "^15.6.2",
    "react-dev-utils": "^5.0.1",
    "react-dom": "^16.4.2",
    "react-helmet": "^5.2.0",
    "react-redux": "^5.0.7",
    "react-router": "^4.3.1",
    "react-router-dom": "^4.3.1",
    "redux": "^4.0.0",
    "redux-saga": "^0.16.0",
    "resolve": "1.6.0",
    "sw-precache-webpack-plugin": "0.11.4",
    "url-loader": "0.6.2",
    "webpack-dev-server": "2.9.4",
    "webpack-manifest-plugin": "1.3.2",
    "whatwg-fetch": "2.0.3"
  },
  "devDependencies": {
    "css-loader": "^0.28.11",
    "enzyme": "^3.5.0",
    "enzyme-adapter-react-16": "^1.3.0",
    "eslint": "4.10.0",
    "eslint-config-react-app": "^2.1.0",
    "eslint-loader": "1.9.0",
    "eslint-plugin-flowtype": "2.39.1",
    "eslint-plugin-import": "2.8.0",
    "eslint-plugin-jsx-a11y": "5.1.1",
    "eslint-plugin-react": "^7.11.1",
    "jest": "20.0.4",
    "less": "^3.8.1",
    "less-loader": "^4.1.0",
    "less-watch-compiler": "^1.12.1",
    "mini-css-extract-plugin": "^0.4.4",
    "react-test-renderer": "^16.4.2",
    "style-loader": "^0.19.1",
    "webpack": "^4.22.0",
    "webpack-cli": "^3.1.2"
  },

export const getTransitionSettings = () => {

    // Will hold the final result.
    const transitionSettings = {
        PageTransitionAppear: UISettings.PageTransitionAppear,
        PageTransitionAppearTimeout: UISettings.PageTransitionAppearTimeout,
        PageTransitionEnterTimeout: UISettings.PageTransitionEnterTimeout,
        PageTransitionLeaveTimeout: UISettings.PageTransitionLeaveTimeout,
        PageTransitionType: null
    };

    // Calculate the effect type of the transition.
    switch (UISettings.PageTransitionType) {
        case enums.PageTransitionType.FADE_IN:
            transitionSettings.PageTransitionType = 'In';
            break;
        case enums.PageTransitionType.FADE_OUT:
            transitionSettings.PageTransitionType = 'Out';
            break;
        case enums.PageTransitionType.RANDOM:
            transitionSettings.PageTransitionType = generateRandomBoolean() ? 'In' : 'Out';
            break;
        default:

            // If not a match case found - Throw exception with relevant parameter name.
            throw new Error(translate.error_invalid.replace('#params#', 'UISettings.PageTransitionType'));
    };

    // Return calculated result.
    return transitionSettings;
}; 


     // This enum defines the effect that the user will experience each time
// that the user browses from page to page.
export const PageTransitionType = createEnum(new Map([
    ['FADE_IN', 'fade_in'],
    ['FADE_OUT', 'fade_out'],
    ['RANDOM', 'random']
]));  


	minimumStringsCount: fakeSettings.minimumSearchKeyStringsCount,
        maximumStringsCount: fakeSettings.maximumSearchKeyStringsCount,
        minimumStringLength: fakeSettings.minimumStringLength,
        maximumStringLength: fakeSettings.maximumStringLength

// This function gets random emails from a given list, since no real search operation is implemented on an API server (Like Node.js one)
export const getRandomEmails = () => {
            // Generate random numbers to take random emails count. Run as long as the new arrays are smaller than the requested emails count.
            while (emailsArray.length < generateData.emailsCount) {

                // Get a random number to pull out from the sample array.
                const number = generateRandomNumber({
                    minimumNumber: 0,
                    maximumNumber: samples.length
                });

                // If the number exists already, continue to the next round.
                if (anArrayOfUniqueNumbers.indexOf(number) >= 0) {
                    continue;
                }

                // Pull out selected sample.
                const sample = samples[number];

                // Insert selected sample into the emails array.
                emailsArray.push({
                    emailId: generateRandomEmailId(),
                    emailUserId: null,
                    emailUserAddedDate: null,
                    emailAddress: sample.emailAddress,
                    emailLink: sample.emailLink,
                    emailCreationDate: new Date(),
                    emailSearchEngine: generateRandomSearchEngine(),
                    emailSearchKey: sample.emailSearchKey,
                    emailComments: sample.emailComments,
                    emailType: generateData.emailType
                });

                // Insert the selected number into the numbers array.
                anArrayOfUniqueNumbers.push(number);
            }
};

// This function gets a data parameter with an emails array list and count,
// and pulls out random emails from the array into a new array and returns it back.
export const getRandomEmails = (randomEmailsData) => {

    // Check the existence and validity of the randomEmailsData parameters.
    if (!randomEmailsData || !validateArrayItems(randomEmailsData.emails) || !validateNumber(randomEmailsData.emailsCount))
};

// This function generates fake emails for testing in a development mode environment.
export const generateFakeEmails = (generateData) => {

    // Validate the generateData parameters. If it does not exist or invalid, don't generate fake emails.
    if (!generateData || !validateNumber(generateData.emailsCount)) {
        // Stop any further actions.
        return;
    }

    // Validate that the emailType is valid. Check the validity of the emailType
    // parameter. If invalid - Don't generate the fake emails.
    if (!validateEnumValue({
            enum: enums.EmailType,
            value: generateData.emailType
        })) {

        // Stop any further actions.
        return;
    }

    // Will hold the array of emails.
    let emailsArray = [];

    // Check if to generate fake emails or sample emails from the logic settings.
    if (logicSettings.isSamplesInsteadFakeEmails) {
        // Load all the samples data from the samples json. This file contains real emails searched manually by Google,
        // but in order to display samples, we would generate the real data with some random fake data, such as
        // the search engines and the comments.
        const samplesJson = require('../assets/data/samples.json');

        // Generate random numbers to take random emails count (In case the length is less then total samples emails count).
        if (samplesJson.samples.length === generateData.emailsCount) {

            // Will hold the array of emails. Loop on all over the sample data and insert them into an samples emails array, and return it.
            emailsArray = samplesJson.samples.map((sample) => {
                return {
                    emailId: generateRandomEmailId(),
                    emailUserId: null,
                    emailUserAddedDate: null,
                    emailAddress: sample.emailAddress,
                    emailLink: sample.emailLink,
                    emailCreationDate: new Date(),
                    emailSearchEngine: generateRandomSearchEngine(),
                    emailSearchKey: sample.emailSearchKey,
                    emailComments: sample.emailComments,
                    emailType: generateData.emailType
                };
            });
        }
        else
        {
            
        }

    } else {
        // Loop and generate fake emails.
        for (let i = 0; i < generateData.emailsCount; i++) {
            emailsArray.push({
                emailId: generateRandomEmailId(),
                emailUserId: null,
                emailUserAddedDate: null,
                emailAddress: generateRandomEmail(),
                emailLink: generateRandomLink(),
                emailCreationDate: generateRandomDate(),
                emailSearchEngine: generateRandomSearchEngine(),
                emailSearchKey: generateRandomSearchKeys(),
                emailComments: generateRandomComments(),
                emailType: generateData.emailType
            });
        }
    }

    // Return fake emails.
    return emailsArray;
};


// This function generates samples emails to generate and display to the user (Or         // Generate random numbers to take random emails count (In case the length is less then total samples emails count).
        if (samplesJson.samples.length < generateData.emailsCount) {

            // Get a random start number.
            const startNumber = generateRandomNumber({
                minimumNumber: 0,
                maximumNumber: randomTextData.maximumStringsCount
            });

            // Get the end number based on the start number position.
            const startNumber = generateRandomNumber({
                minimumNumber: 0,
                maximumNumber: randomTextData.maximumStringsCount
            });
        }

to save in the database) as sample results.
const generateSamplesEmails = () => {

    // Load all the samples data from the samples json. This file contains real emails search manually by Google,
    // but in order to display samples, we would generate the real data with some random fake data, such as
    // the search engines and the comments.
    const samplesJson = require('../assets/data/samples.json');

    // Will hold the array of emails. Loop on all over the sample data and insert them into an samples emails array, and return it.
    return samplesJson.samples.map((sample) => {
        return {
            emailId: generateRandomEmailId(),
            emailUserId: null,
            emailUserAddedDate: null,
            emailAddress: sample.emailAddress,
            emailLink: sample.emailLink,
            emailCreationDate: new Date(),
            emailSearchEngine: generateRandomSearchEngine(),
            emailSearchKey: sample.emailSearchKey,
            emailComments: sample.emailComments,
            emailType: enums.EmailType.SEARCH
        };
    });
};


    /*     // Will hold the array of emails.
        const emailsArray = [];

        // Loop and generate fake emails.
        for (let i = 0; i < generateData.emailsCount; i++) {
            emailsArray.push({
                emailId: generateRandomEmailId(),
                emailUserId: null,
                emailUserAddedDate: null,
                emailAddress: generateRandomEmail(),
                emailLink: generateRandomLink(),
                emailCreationDate: generateRandomDate(),
                emailSearchEngine: generateRandomSearchEngine(),
                emailSearchKey: generateRandomSearchKeys(),
                emailComments: generateRandomComments(),
                emailType: generateData.emailType
            });
        }

        // Return fake emails.
        return emailsArray;  */

            emailAddress: generateRandomEmail(),
            emailLink: generateRandomLink(),
            emailCreationDate: generateRandomDate(),
            emailSearchEngine: generateRandomSearchEngine(),
            emailSearchKey: generateRandomSearchKeys(),
            emailComments: generateRandomComments(),

URLS
----

Comments
--------

Emails
------

Search keys
-----------    

apiBaseUserAuthenticationUrl: 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/',

apiBaseUserAuthenticationKey: 'AIzaSyAPZZY47KGG2aNteQ3p9V8N5o8jy7K5znE'

'https://burger-builder-84921.firebaseio.com/',

a. Add npm install --save-dev webpack webpack-cli less less-loader css-loader style-loader mini-css-extract-plugin to packages list in this document.

sample

Working on a generic system to create in a few steps basic templates for simple websites on ASP.NET.
Communicating with extremal REST API (Old .ASHX files) for small projects.
Migrating with external API and building the product page (Embed) in Eyefeelit.

Netbiz Multimedia

Boutique

Military police

// Fetch fake emails.
    let emails = yield call(generateFakeEmails, {
        emailsCount: action.searchData.emailsCount,
        emailType: enums.EmailType.FAKE
    });

abcdefghijklmnopqrstuvwxyz 

user authenticated
user authentication
successfully
and vice versa
// Stop any further actions.

Check for duplicates.
------------------
manageEmail *
userAuthenticationMode *
searchModalToggleStartSaga *
authenticationRequiredModalType *
basicEmailValidationData *
isMoreInformationMode *
searchAddEmailFailSaga *
userEmailsTotalCount *
userAuthentication *
userGetEmailsErrorData *
userLocalStorage *
userPagerUpdateStartSaga *
userCounterUpdateStartSaga *
userErrorDeleteEmailSaga *
userGetEmailsProcessStartSaga *
userAuthenticationInputChangeData *
userEmailsTotalCountResult *
userDeleteEmailFailSaga *
addedDate *
searchErrorAddEmailStartSaga *
searchVerifyFakeEmailExistsOnDatabaseStartSaga *
searchStoreFakeEmailsStartSaga *
minimumEmailsCountToShowPager *
onSearchOptionsToggleSuccess *
searchErrorStartSaga *
isFakeProcess *
userAuthenticationModeChange *
userAuthenticationProcess *
onUserAuthenticationCheckState *
userEmailsPagesCountToShow *
------------------




property
property


   if (!isMatchRegularExpressionData || !isMatchRegularExpressionData.targetType || !isMatchRegularExpressionData.targetValue) {

/* // This function validates the props of a specific component and also validates button/input type on one of the props.
export const validateParametersAndType = (validateParametersData) => {

    // Check existence of parameters.
    if (!validateParametersData || !validateParametersData.targetParameter || !validateParametersData.validationType) {

        // Throw an exception with all relevant parameter names.
        throw new Error(translate.error_missing.replace('#params#', getErrorParametersString(['validateParametersData', 'targetParameter', 'validationType'])));
    }

    // Validate on the basic validation function.
    validateParameters(validateParametersData);

    // Determine the function to validate on a specific field.
    // Validate that the type of the input/button is not invalid.
    switch (validateParametersData.validationType) {

        case enums.ValidationFunctionType.INPUT:

            // Return calculated result.
            if (['text', 'email', 'password'].indexOf(validateParametersData.props[validateParametersData.targetParameter]) < 0) {

                // Throw an exception with the relevant parameter name.
                throw new Error(translate.error_invalid.replace('#params#', validateParametersData.props[validateParametersData.targetParameter]));
            }
            break;
        case enums.ValidationFunctionType.BUTTON:

            // Return calculated result.
            if (['button', 'submit'].indexOf(validateParametersData.props[validateParametersData.targetParameter]) < 0) {

                // Throw an exception with the relevant parameter name.
                throw new Error(translate.error_invalid.replace('#params#', validateParametersData.props[validateParametersData.targetParameter]));
            }
            break;
        default:

            // Throw an exception with the relevant parameter name.
            throw new Error(translate.error_invalid.replace('#params#', 'validationType'));
    }
}; */

searchOptionType={enums.SearchElementType.MODE}

/*     componentDidUpdate() {

        const props = this.props;

        // Bind all the functions.
        this.handleUserAuthenticationModeChangeClick = this.handleUserAuthenticationModeChangeClick.bind(this, props.userAuthenticationMode ===
            enums.UserAuthenticationModeType.LOGIN ? enums.UserAuthenticationModeType.REGISTRATION : enums.UserAuthenticationModeType.LOGIN);
    } */    

emailId: PropTypes.string.isRequired,
    emailUserId: PropTypes.string,
    emailUserAddedDate: PropTypes.instanceOf(Date),
    emailAddress: PropTypes.string.isRequired,
    emailLink: PropTypes.string.isRequired,
    emailCreationDate: PropTypes.instanceOf(Date).isRequired,
    emailSearchEngine: PropTypes.string.isRequired,
    emailSearchKey: PropTypes.string.isRequired,
    emailComments: PropTypes.string,
    emailType: PropTypes.string.isRequired,
    emailActionType: PropTypes.string.isRequired,
    isEmailMoreInformationMode: PropTypes.bool.isRequired

/*   state = {
    isComponentMounted: false
  } */

/*     setTimeout(() => this.setState({ isComponentMounted: true }), 500); */

onSearchOnLoadSuccess

type: actionTypes.appActions.APP_ON_LOAD_SUCCESS

    // This field will determine if to call the searchStoreFakeEmailsStartSaga
    // saga to store fake emails on the Firebase database.
    isGenerateFakeEmails: false,

searchKeyErrorMessage
searchOptionsGeneralErrorMessage
searchOptions.errorMessage        

            searchOptionsGeneralErrorMessage={props.searchOptionsGeneralErrorMessage}
                    searchKeyErrorMessage={props.searchKeyErrorMessage}                      


  emailAddress={props.addEmail.emailAddress}
                        commentsValue={props.addEmailComments}
                        errorMessage={props.addEmail.errorMessage}

handleRedirectToAuthenticationClick

handleRedirectToAuthenticationClick


commentsChangeHandler

handleCommentsChange


handleSearchEmails


handleToggleModal

handleToggleModalClick


toggleSearchOptionsHandler

handleToggleSearchOptionsClick

onHomeClickHandler

handleHomeClick

handleScrollToElement

scrollToElement

checkAuthentication

handleAuthentication

handleCheckAuthentication


handleInitRender

manageEmailsContent

handleEmailsContent


searchOptionChangeHandler

handleSearchOptionChange

toggleAuthenticationModal

handleToggleAuthenticationModal

searchSelectChangeHandler

handleSearchSelectChange

manageModals

handleModals


toggleModalHandler

handleToggleModal


searchChangeHandler

handleSearchChange


searchClickHandler

handleSearchClick


addEmailClickHandler

handleAddEmailClick


redirectToAuthenticationClickHandler

handleRedirectToAuthenticationClick
onUserAuthenticationModeChangeClickHandler

handleUserAuthenticationModeChangeClick


onUserAuthenticationLoginRegisterClickHandler

handleUserAuthenticationLoginRegisterClick


onUserAuthenticationInputChange

handleUserAuthenticationInputChange




deleteEmailClickHandler

handleDeleteEmailClick


cancelModalClickHandler

handleCancelModalClick


counterChangeHandler

handleCounterChangeClick


changePageHandler

handleChangePageClick


moreInformationToggleClickHandler

handleMoreInformationToggleClick


toggleDeleteEmailModalHandler

handleToggleDeleteEmailModalClick   


 pagesCountToShow
    currentPageNumber
    totalEmailsCount
    totalPagesCount


import { isUserVerifiedAuthentication } from '../../../utils/userAuthenticationUtils';   

 if (!validateAPIResponse(response)) {

userAddEmailProcessSaga
userAddEmailToDatabaseProcessStartSaga
userDeleteEmailFromDatabaseProcessStartSaga

import { validateArrayItems } from '../../../utils/validationUtils';


/* // ToDo: Need comments about what this function does.
// Note: In the case of deleting email this validation function validation is 
// enough and does not need further validation, unlike the add email operation validation.
export const validateBasicAddDeleteEmailRequest = (basicEmailValidationData) => {

    // Create base template result to return with the error console and error to display to the user.
    const validationResult = {
        emailItem: null,
        errorToConsole: null,
        errorMessage: null
    };

    // Validate the existence of the basicEmailValidationData parameters, and the validity of the user parameters.
    // If any of these parameters are missing or invalid - Something's not right with the application - 
    // Show a general message to the user.
    if (!basicEmailValidationData || !basicEmailValidationData.emails || basicEmailValidationData.emails.length <= 0 ||
        !basicEmailValidationData.userAuthentication || !basicEmailValidationData.userAuthentication.userId ||
        !basicEmailValidationData.userAuthentication.userToken || !basicEmailValidationData.userAuthentication.isUserAuthenticated() ||
        !basicEmailValidationData.emailId) {

        // Assign the error details to print to the console.
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.MISSING,
            parameters: ['emails', 'userAuthentication', 'userId', 'userToken', 'emailId'],
            functionName: getFunctionName()
        };

        // Return the validation results.
        return validationResult;
    }

    // Get the specific email row from the email's list by the fetched Id.
    // If the email row does not exist by the Id - Something is wrong, display error message to the user.
    validationResult.emailItem = basicEmailValidationData.emails.find(email => email.emailId === basicEmailValidationData.emailId);

    // Check if the emailItem exists.
    if (!validationResult.emailItem) {

        // Clear any assigned values and assign the error details to print to the console.
        validationResult.emailItem = null;
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.MISSING,
            parameters: ['emailItem'],
            functionName: getFunctionName()
        };

        // Return the validation results.
        return validationResult;
    }

    // Check that the email was not already added / deleted from / to the user's emails list. If so - Don't do nothing.
    // If the email is already added / deleted and clicked on again - Don't do nothing.
    if (validationResult.emailItem.emailActionType && validationResult.emailItem.emailActionType === basicEmailValidationData.emailActionType) {

        // Clear any assigned values and assign the error details to print to the console.
        validationResult.emailItem = null;
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.INVALID,
            parameters: ['emailActionType'],
            functionName: getFunctionName()
        };
    }

    // Return the validation results.
    return validationResult;
}; */

/* // When the user clicks on the icon next to each email row on the search page (the home page)
// The modal will be open with all relevant details that are about to be added to users's list.
export function* searchAddEmailModalToggleStartSaga(action) {
    // Validate existence of action parameters. If one of the parameters are
    // missing - User clicked on the X on add email modal, or something is wrong, 
    // don't display the modal to the user. Either cases - Hide the add email modal window.
    if (!action.toggleAddEmailModalData.emailId || !action.toggleAddEmailModalData.emails || action.toggleAddEmailModalData.emails.length <= 0) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Create the template to update the state.
    const addEmailData = {
        emailId: null,
        email: null,
        errorMessage: null
    };

    // Get the emailId selected by the user. Then, validate that the id exists.
    // If not - Something is wrong, don't display the modal to the user.
    addEmailData.emailId = action.toggleAddEmailModalData.emailId.substr(6);
    if (!addEmailData.emailId) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Get the specific email row from the email's list by the fetched Id.
    // If the email row does not exist by the Id - Something is wrong, don't display the modal to the user.
    const email = action.toggleAddEmailModalData.emails.find(item => item.emailId === addEmailData.emailId);
    if (!email) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Check that the email was not already added to the user's emails list. If so - Don't do nothing.
    // If the email is already added and clicked on again - No need to do nothing.
    if (email.emailActionType && email.emailActionType === enums.EmailActionType.ADDED) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Set the email address from the selected email row to the success data.
    addEmailData.email = email.emailAddress;

    // Call the success toggle action to raise up the add email modal window.
    yield put(actions.onSearchAddEmailModalToggleSuccess({
        isShowModal: true,
        addEmail: addEmailData
    }));
}
 */







//-----------------------------------------------------------------

/* toggleRemoveEmailModalHandler = (e) => {
    // Stop any default action.
    e.preventDefault();

    if (!e.currentTarget.dataset.id) {
        throw new Error(translate.error_not_found.replace('#param#', 'emailId'));
    }

    const emailData = {
        emailId: null,
        emailRow: null,
        isShowDeleteEmailModal: true
    };

    if (e.currentTarget.dataset.id) {
        emailData.emailId = e.currentTarget.dataset.id.substr(6);
        if (!emailData.emailId) {
            throw new Error(translate.error_not_found.replace('#param#', 'emailId'));
        }
    }

    emailData.emailRow = this.state.emails.find(email => email.id === emailData.emailId);
    if (emailData.emailRow) {
        // Check that the email was not already deleted from user's emails list.
        if (emailData.emailRow.emailActionType === enums.EmailActionType.DELETED) {
            emailData.isShowDeleteEmailModal = false;
        }
    }
    else {
        emailData.isShowDeleteEmailModal = false;
    }

    if (emailData.isShowDeleteEmailModal) {
        this.manageDeleteEmail({
            emailId: emailData.emailId,
            email: emailData.emailRow.email,
            isToggleModal: true
        });
    }
    else {
        this.manageDeleteEmail({
            emailId: null,
            email: null,
            isShowModal: false
        });
    }
} */

//-----------------------------------------------------------------









/*     // Check that the counter value is different from the current counter value. If it's the same, don't do anything.
    if (userCounterUpdateData.userEmails.userEmailsCountPerPage === updatedCounter) {
        return validationResult;
    } */

/* counterChangeHandler = (e) => {
    // Check that value exists.
    if (!e.target.value) {
        throw new Error(translate.error_missing.replace('#params#', 'counter number'));
    }

    // Check that the counter value is a number.
    const updatedCounter = Number(e.target.value);
    if (isNaN(updatedCounter)) {
        throw new Error(translate.error_invalid.replace('#params#', 'counter number'));
    }

    const state = this.state;

    // Check that the counter value is different from the current counter value.
    if (state.emailsNavigation.emailsCountPerPage === updatedCounter) {
        return;
    }

    // Make a shallow copy of the email's navigation and reset the current page number to start.
    const updatedEmailsNavigation = updateObject({
        oldObject: state.emailsNavigation,
        updatedProperties: {
            currentPageNumber: 1,
            emailsCountPerPage: updatedCounter
        }
    });

    // Update the navigation state and render emails's list again.
    this.setState({ emailsNavigation: updatedEmailsNavigation }, () => this.getEmailsToDisplay());
} */

/*    // Check that the element that was clicked is not the X icon.
   if (!action.emailId || action.e.target.className === 'fa fa-close') {
       return;
   }

   // Delete email from user's emails list.
   // Make a shallow copy of the emails.
   const emails = [...state.emails];

   // Get the index of the email.
   const emailToUpdateIndex = emails.findIndex(email => email.id === emailId);
   if (emailToUpdateIndex < 0) {
       throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
   }
   emails[emailToUpdateIndex].isMoreInformationMode = !emails[emailToUpdateIndex].isMoreInformationMode;
   this.setState({ emails: emails }); */

/* getEmailsToDisplay = () => {
    const state = this.state;

    // All relevant data stored for this function.
    const emailsData = {
        emailsDataBase: null,
        totalEmailsCount: 0,
        totalPagesCount: 0,
        updatedEmailsNavigation: null,
        indexStart: 0,
        indexEnd: 0,
        emails: null
    };

    // Set loader to be on before starting the operation.
    this.setState({ isLoadingEmails: true });

    // Get emails from the database (fake in development) if this is the first time of rendering the page.
    // Also, with the current result of the emails, get the total number of emails.
    if (!state.emailsDataBase || state.emailsDataBase.length <= 0) {
        emailsData.emailsDataBase = generateFakeEmails({
            emailsCount: 24,
            emailType: enums.EmailType.FAKE
        });
        emailsData.totalEmailsCount = emailsData.emailsDataBase.length;
        this.setState({
            totalEmailsCount: emailsData.totalEmailsCount,
            emailsDataBase: emailsData.emailsDataBase
        });
    }
    else {
        emailsData.totalEmailsCount = state.totalEmailsCount;

        // If already loaded before, display only the emails 
        // that are not deleted already from the database.
        emailsData.emailsDataBase = state.emailsDataBase.filter(email => {
            return email.emailActionType !== enums.EmailActionType.DELETED;
        });
    }

    // Calculate how many pages to show in pager.
    emailsData.totalPagesCount = Number(emailsData.totalEmailsCount / state.emailsNavigation.emailsCountPerPage);
    if (Number(emailsData.totalEmailsCount % state.emailsNavigation.emailsCountPerPage) > 0) {
        emailsData.totalPagesCount++;
    }

    // Make a shallow copy of the email's navigation.
    emailsData.updatedEmailsNavigation = updateObject({
        oldObject: state.emailsNavigation,
        updatedProperties: {
            totalPagesCount: Math.floor(emailsData.totalPagesCount)
        }
    });

    // Calculate the indexes to slice from the database.
    emailsData.indexStart = (state.emailsNavigation.currentPageNumber - 1) * state.emailsNavigation.emailsCountPerPage;
    emailsData.indexEnd = emailsData.indexStart + state.emailsNavigation.emailsCountPerPage;

    // Slice the emails from the database by the calculated section.
    emailsData.emails = [...emailsData.emailsDataBase].slice(emailsData.indexStart, emailsData.indexEnd);

    // Update all states and reset deletedEmailsCount to avoid refreshing the page when less then 3 emails are deleted.
    this.getEmailsTimeOut = setTimeout(() => {
        this.setState({
            emails: emailsData.emails,
            totalEmailsCount: emailsData.totalEmailsCount,
            emailsNavigation: emailsData.updatedEmailsNavigation,
            deletedEmailsCount: 0,
            isLoadingEmails: false
        });
    }, 500);
}
 */

/* 
userEmailsTotalCount: userEmails.userEmailsTotalCount,
userEmailsCountPerPage: userEmails.userEmailsCountPerPage,
userEmailsPagesTotalCount: userEmails.userEmailsPagesTotalCount,
userEmailsCurrentPageNumber: userEmails.userEmailsCurrentPageNumber, */

/* export const getResponseError = (error) => {
    // Print the original error to the console in any case
    console.log(error);

    // Check if a specific error message exists. If not - Return general error message.
    if (!error || !error.response || !error.response.data || !error.response.data.error || !error.response.data.error.message) {
        return translate.error_general;
    }

    // Return the specific error message from the API server.
    return error.response.data.error.message;
}; */

//import translate from '../translate/translate';

/*     // Validate that the email address is identical and verify it's really the same email address.
    // If the email row doesn't have the same email address - Something is wrong, don't display the modal to the user.
    if (emailItem.emailAddress !== toggleManageEmailModal.emailAddress) {

        // Clear any values assigned and assign the error details to print to the console.
        validationResult.emailId = null;
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.INVALID,
            parameters: ['emailAddress'],
            functionName: getFunctionName()
        };

        // Return validation results.
        return validationResult;
    } */

/*     // Create a new instance of userEmails to reset all the settings configurations of the page.
    validationResult.emails = toEmails({
        emailsCount: null,
        emailsArray: validationResult.emails,
        isFakeProcess: false
    });
 */

/* changePageHandler = (pageNumber) => {

    // Validate the page number / value.
    if (!pageNumber) {
        throw new Error(translate.error_missing.replace('#params#', 'pageNumber'));
    }

    const state = this.state;

    // Check if the clicked page is not the current page.
    if (state.emailsNavigation.currentPageNumber === pageNumber) {
        return;
    }

    // Check which type of page actually clicked.
    switch (pageNumber) {
        case enums.PagerLink.NEXT:
            // Check if there is an option to go next or the current page is the last page.
            if (state.emailsNavigation.currentPageNumber === state.emailsNavigation.totalPagesCount) {
                return;
            }
            pageNumber = state.emailsNavigation.currentPageNumber + 1;
            break;
        case enums.PagerLink.PREVIOUS:
            // Check if there is an option to go previous or the current page is the first page.
            pageNumber = state.emailsNavigation.currentPageNumber - 1;
            if (pageNumber <= 0) {
                return;
            }
            break;
        default:
            // If not a number (except next or previous) - throw exception.
            if (isNaN(pageNumber)) {
                throw new Error(translate.error_invalid.replace('#params#', 'pageNumber'));
            }

            // Check that the page number is on the limits.
            if (pageNumber <= 0 || pageNumber > state.emailsNavigation.totalPagesCount) {
                throw new Error(translate.error_invalid.replace('#params#', 'pageNumber'));
            }
            break;
    }

    // Make a shallow copy of the email's navigation.
    const updatedEmailsNavigation = updateObject({
        oldObject: state.emailsNavigation,
        updatedProperties: {
            currentPageNumber: pageNumber
        }
    });

    // Update the navigation state and render emails's list again.
    this.setState({ emailsNavigation: updatedEmailsNavigation }, () => this.getEmailsToDisplay());
}
 */


/*         const state = this.state;
        
        // ToDo: Add logic of delete email from user's emails.
        if (!state.deleteEmail.emailId) {
            throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
        }
        
        // Set the state.
        this.setState({ isLoadingModal: true });
        
        // Delete email from user's emails list.
        // Make a shallow copy of the emails.
        const emails = [...state.emails];
        
        // Get the index of the email.
        const emailToUpdateIndex = emails.findIndex(email => email.id === state.deleteEmail.emailId);
        if (emailToUpdateIndex < 0) {
            throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
        }
        
        // Simulate loading until real ajax call.
        setTimeout(() => {
            this.setState({ isLoadingModal: false });
        
            // Determine if to simulate error on deleting the email.
            let deleteError = false;
            if (deleteError) {
                this.setState({ modalErrorMessage: translate.error_general });
                setTimeout(() => {
                    this.resetDeleteEmail();
                    this.setState({ modalErrorMessage: null });
                }, 1000);
            }
            else {
                // Reset all delete email's state properties.
                this.resetDeleteEmail();
        
                setTimeout(() => {
                    // Update the email.
                    emails[emailToUpdateIndex].emailActionType = enums.EmailActionType.DELETED;
        
                    // There is a logic to refresh the page each 3 deletes, and check for emails left in a pager page.
                    // If users don't have pager (less than a logic settings number of emails), no need for the logic.
                    if (state.totalEmailsCount >= logicSettings.minimumEmailsCountToShowPager) {
                        // In a real world database you wouldn't delete a row database - Just change the state of the active field to false, for statistics.
                        // Will determine which callback to run after setState completes.
                        let executeFunc = this.initRender;
        
                        this.setState(prevState => {
                            // Since delete email don't effect on pager / counter, we want to initialize the page after some time of deleting emails.
                            // So the logic is that after a number from logic settings is exceeded, deletes without refreshing the page, there will be a render of the page automatically.
                            // This logic applies only if the user has more than the total number from the logic settings of emails.
                            let updatedDeletedEmailsCount = prevState.deletedEmailsCount + 1;
                            if (updatedDeletedEmailsCount > (logicSettings.emailsCountToRefreshPage - 1) || (prevState.emails.length - 1) <= 0) {
                                executeFunc = this.getEmailsToDisplay;
                            }
        
                            // Also, check if after delete there are still active emails remaining in the
                            // page, if not, refresh the page, and reset the current page to start. 
                            // Also, if the number of emails left does not fit the pager, render the page again.
                            let updatedEmailsNavigation = prevState.emailsNavigation;
                            const emailsCount = state.emails.filter(email => {
                                return email.emailActionType !== enums.EmailActionType.DELETED;
                            });
        
                            if (emailsCount.length <= 0 ||
                                (state.emails.length % state.emailsNavigation.emailsCountPerPage <= 0 && prevState.emailsNavigation.currentPageNumber === 1)) {
                                executeFunc = this.getEmailsToDisplay;
        
                                // Make a shallow copy of the email's navigation and reset the current page number to start.
                                updatedEmailsNavigation = updateObject({
                                    oldObject: state.emailsNavigation,
                                    updatedProperties: {
                                        currentPageNumber: 1
                                    }
                                });
                            }
        
                            return {
                                totalEmailsCount: prevState.totalEmailsCount - 1,
                                deletedEmailsCount: updatedDeletedEmailsCount,
                                emailsNavigation: updatedEmailsNavigation,
                                emails: emails
                            };
                        }, () => { executeFunc(); });
                    }
                    else {
                        // Update the state and the titles.
                        this.setState(prevState => {
                            return {
                                totalEmailsCount: prevState.totalEmailsCount - 1,
                                emails: emails
                            };
                        }, () => { this.initRender(); });
                    }
                }, 100);
            }
        }, 1000); */

// yield all([
// Print error details to the console.
//  call(printErrorToConsole, deleteEmailFailData),

// Show to the user the general error.
// put(actions.onSearchAddEmailProcessFail(translate.error_general)),

// After a 5 seconds delay, close the modal window.
//    delay(5000),

// Call the success toggle action to raise up the add email modal window.
//   put(actions.onSearchAddEmailModalToggleReset())
// ]);

/* import translate from '../../../translate/translate'; */


/*     // Validate for existence of userGetEmailsErrorData parameter. If not exists - Don't do nothing.
    if (!userGetEmailsErrorData) {

        // Stop any further actions.
        return;
    }

    // Check the validity of the errorType parameter. If not valid - Don't do nothing.
    let errorMessage = null;
    switch (userGetEmailsErrorData.errorType) {
        case enums.ErrorType.MISSING:
            errorMessage = translate.error_missing;
            break;
        case enums.ErrorType.INVALID:
            errorMessage = translate.error_invalid;
            break;
        default:
            return;
    }

    // If the error message is not empty - Return to display it to the user.
    if (!errorMessage) {
        return;
    }

    // Replace the relevant parameters that are related to the error.
    errorMessage = errorMessage.replace('#params#', getErrorParametersString(userGetEmailsErrorData.errorParameters));
    if (userGetEmailsErrorData.functionName) {
        errorMessage += ` functionName: ${userGetEmailsErrorData.functionName}`;
    }

    // Print the error message to the console.
    console.error(errorMessage); */


/* // Inner saga to handle any case of error on the add email process.
function* searchErrorAddEmailStartSaga(validationResult) {
    // Validate for existence of validationResult parameter. If not exists - Don't do nothing.
    if (!validationResult) {
        return;
    }

    // Create default error template. If there is an error message, put it. If not - Display general error message.
    const errorMessage = validationResult.errorMessage ? validationResult.errorMessage : translate.error_general;

    // Check if the error is console error (internal error that is not related to any action of the user - An application error).
    if (validationResult.errorToConsole) {
        let consoleErrorMessage = null;
        switch (validationResult.errorToConsole.errorType) {
            case enums.ErrorType.MISSING:
                consoleErrorMessage = translate.error_missing;
                break;
            case enums.ErrorType.INVALID:
                consoleErrorMessage = translate.error_invalid;
                break;
            default:
                return;
        }

        // Replace the relevant parameters that related to the error and print the general to console with details.
        consoleErrorMessage = consoleErrorMessage.replace('#params#', getErrorParametersString(validationResult.errorToConsole.parameters));
        if (validationResult.errorToConsole.functionName) {
            consoleErrorMessage += ` functionName: ${validationResult.errorToConsole.functionName}`;
        }

        // Print the error to the console.
        console.error(consoleErrorMessage);
    }

    // Call the failure process action.
    yield put(actions.onSearchAddEmailProcessError(errorMessage));
}
 */
/* function* userGetEmailsProcessPreparationSaga(isFirstPageLoad) {
    if (isFirstPageLoad) {
        // Call the preparation saga to display the user loading animation 
        // while performing a call to the API server to bring all user's emails list.
        // Also, update the state that the component is mounted.
        yield put(actions.onUserGetEmailsProcessFirstLoadPreparation());
    } else {
        // Call the preparation saga to display the user loading animation 
        // while performing a call to the API server to bring all user's emails list.
        yield put(actions.onUserGetEmailsProcessPreparation());
    }
} */

/* import * as userAuthenticationUtils from '../../../utils/userAuthenticationUtils'; */

/*     // If any error from the update we need to print it
    // and show the user a general error message.
    if (userEmailsTotalCountResult.errorMessage || userEmailsTotalCountResult.errorToConsole) {

        // Call the error saga to show a general error message to the user and console the error.
        yield call(userDeleteEmailFailSaga, userEmailsTotalCountResult);
    } */

/* import { toEmails } from '../../../modals/conversion/email'; */

/*     let validationResult = yield call(userEmailsUtils.validateBasicAddDeleteEmailRequest, action.deleteEmailData); */

/* let validationResult = yield call(userEmailsUtils.validateBasicAddDeleteEmailRequest, {
    userAuthentication: action.deleteEmailData.userAuthentication,
    emailId: action.deleteEmailData.emailId,
    emails: action.deleteEmailData.userEmails.userEmailsList
});
 */

/*     // Get the first top emailId from the database response.
   //const emailTopId = emailsKeys[0]; */

/*     // Check if the errorMessage exists, if so - Print it to console.
    if (errorData.errorMessage) {

        // Print the error message to console.
        console.error(errorData.errorMessage);
    } */

    /*         creationYear: getNumber({
            targetNumber: settings.application_creation_year,
            defaultNumber: 2018 // Default value in case the settings value is invalid.
        }), */

/*     // Check the validity of the searchErrorData parameter. If not valid - Don't do nothing.
    let errorMessage = null;
    switch (searchErrorData.errorType) {
        case enums.ErrorType.MISSING:
            errorMessage = translate.error_missing;
            break;
        case enums.ErrorType.INVALID:
            errorMessage = translate.error_invalid;
            break;
        default:
            return;
    }

    // Replace the relevant parameters that are related to the error.
    errorMessage = errorMessage.replace('#params#', getErrorParametersString(searchErrorData.errorParameters));

    // Print the error to the console.
    console.error(errorMessage); */

/*         let errorMessage = null;
        switch (validationResult.errorToConsole.errorType) {
            case enums.ErrorType.MISSING:
                errorMessage = translate.error_missing;
                break;
            case enums.ErrorType.INVALID:
                errorMessage = translate.error_invalid;
                break;
            default:
                return;
        }
        // Replace the relevant parameters that related to the error and call the failure process action.
        errorMessage = errorMessage.replace('#params#', getErrorParametersString(validationResult.errorToConsole.parameters));
        console.error(errorMessage); */

/*     // Check if the error is console error (internal error that is not related to any action of the user - An application error).
    if (validationResult.errorToConsole) {
        let consoleErrorMessage = null;
        switch (validationResult.errorToConsole.errorType) {
            case enums.ErrorType.MISSING:
                consoleErrorMessage = translate.error_missing;
                break;
            case enums.ErrorType.INVALID:
                consoleErrorMessage = translate.error_invalid;
                break;
            default:
                return;
        }

        // Replace the relevant parameters that related to the error and print the general to console with details.
        consoleErrorMessage = consoleErrorMessage.replace('#params#', getErrorParametersString(validationResult.errorToConsole.parameters));
        if (validationResult.errorToConsole.functionName) {
            consoleErrorMessage += ` functionName: ${validationResult.errorToConsole.functionName}`;
        }

        // Print the error to the console.
        console.error(consoleErrorMessage);
    } */

/*     // Create the template to update the state.
let validationResult = {
    emailId: null,
    emailAddress: null,
    errorType: null,
    parameters: null,
    functionName: null
}; */

/* // When the user clicks on the icon next to each email row on the search page (the home page)
// The modal will be open with all relevant details that are about to be added to users's list.
export function* searchAddEmailModalToggleStartSaga(action) {
    // Validate existence of action parameters. If one of the parameters are
    // missing - User clicked on the X on add email modal, or something is wrong, 
    // don't display the modal to the user. Either cases - Hide the add email modal window.
    if (!action.toggleAddEmailModalData.emailId || !action.toggleAddEmailModalData.emails || action.toggleAddEmailModalData.emails.length <= 0) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Create the template to update the state.
    const addEmailData = {
        emailId: null,
        email: null,
        errorMessage: null
    };

    // Get the emailId selected by the user. Then, validate that the id exists.
    // If not - Something is wrong, don't display the modal to the user.
    addEmailData.emailId = action.toggleAddEmailModalData.emailId.substr(6);
    if (!addEmailData.emailId) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Get the specific email row from the email's list by the fetched Id.
    // If the email row does not exist by the Id - Something is wrong, don't display the modal to the user.
    const email = action.toggleAddEmailModalData.emails.find(item => item.emailId === addEmailData.emailId);
    if (!email) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Check that the email was not already added to the user's emails list. If so - Don't do nothing.
    // If the email is already added and clicked on again - No need to do nothing.
    if (email.emailActionType && email.emailActionType === enums.EmailActionType.ADDED) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Set the email address from the selected email row to the success data.
    addEmailData.email = email.emailAddress;

    // Call the success toggle action to raise up the add email modal window.
    yield put(actions.onSearchAddEmailModalToggleSuccess({
        isShowModal: true,
        addEmail: addEmailData
    }));
} */

/*  
//import { getEnvironment } from '../../../utils/coreUtils';
// Verify that the environment is 'development'. If it's production, don't do anything.    if (getEnvironment() !== 'development') {

        // If the environment is production (test not exists yet) - Don't do anything. This operation meant to be for development only.
        return;
    }
 */

/*     // This saga is only for a case that no server side implemented (In case no server side is built),
    // and fake emails are not found in the Firebase database, auto-fill fake emails to the database
    // to generate emails from the server and save them on the state. When a server side implementation
    // will exist - There will be no need for this saga, since it's legit that search operation
    // process will have no results with specific given key not found any emails on any search engine.
    emails = yield call(verifyFakeEmailExistsOnDatabase, emails); */

/*     return cloneObject({
    }); */


    // Return a new object array.
    //return array.map(obj => Object.assign(Object.create(Object.getPrototypeOf(obj)), obj));

/*     // Clear the state of the userAuthentication class instance.
    yield put(actions.onUserAuthenticationLogoutSuccess());

    // Clear the state of the userEmails class instance.
    yield put(actions.onUserEmailsAuthenticationLogoutSuccess()); */

/*     // Set the userEmails class instance in state.
    yield 

    // Set the userAuthentication class instance in state.
    yield put(actions.onUserAuthenticationProcessSuccess(userInstances.userAuthentication)); */

/*     // Check the validity of the errorType parameter. If not valid - Don't do nothing.
    let errorMessage = null;
    switch (userAuthenticationErrorData.errorType) {
        case enums.ErrorType.MISSING:
            errorMessage = translate.error_missing;
            break;
        case enums.ErrorType.INVALID:
            errorMessage = translate.error_invalid;
            break;
        default:
            return;
    }

    // If the error message is not empty - Return to display it to the user.
    if (!errorMessage) {
        return;
    }

    // Replace the relevant parameters that are related to the error.
    errorMessage = errorMessage.replace('#params#', getErrorParametersString(userAuthenticationErrorData.errorParameters));
    console.error(errorMessage); */

/* // Generate the error message to display to the user after the API call returns an error.
export const getSearchErrorMessage = (error) => {
    // Console the user the error message if needed (For developers).
    console.error(error);

    // Return the error message to the user.
    return translate.error_general;
}; */

/* // ToDo: Need comments about what this function does.
// Note: In the case of deleting email this validation function validation is 
// enough and does not need further validation, unlike the add email operation validation.
export const validateBasicAddDeleteEmailRequest = (manageEmailData) => {
    // Create base template result to return with the error console and error to display to the user.
    const validationResult = {
        emailItem: null,
        errorToConsole: null,
        errorMessage: null
    };

    // Validate the existence of the manageEmailData parameters, and the validity of the user parameters.
    // If any of these parameters are missing or invalid - Something's not right with the application - 
    // Show a general message to the user.
    if (!manageEmailData || !manageEmailData.emails || manageEmailData.emails.length <= 0 || !manageEmailData.userAuthentication ||
        !manageEmailData.userAuthentication.userId || !manageEmailData.userAuthentication.userToken ||
        !manageEmailData.userAuthentication.isUserAuthenticated() || !manageEmailData.emailId) {
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.MISSING,
            parameters: ['manageEmailData', 'emails', 'userAuthentication', 'userId', 'userToken', 'emailId'],
            functionName: getFunctionName()
        };

        // Return the validation results.
        return validationResult;
    }

    // Get the specific email row from the email's list by the fetched Id.
    // If the email row does not exist by the Id - Something is wrong, display error message to the user.
    validationResult.emailItem = manageEmailData.emails.find(row => row.emailId === manageEmailData.emailId);
    if (!validationResult.emailItem) {

        // Set the error console with the error's relevant information data.
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.MISSING,
            parameters: ['emailItem'],
            functionName: getFunctionName()
        };

        // Return the validation results.
        return validationResult;
    }

    // Check that the email was not already added / deleted from / to the user's emails list. If so - Don't do nothing.
    // If the email is already added / deleted and clicked on again - Don't do nothing.
    if (validationResult.emailItem.emailActionType && validationResult.emailItem.emailActionType === manageEmailData.emailActionType) {
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.INVALID,
            parameters: ['emailActionType'],
            functionName: getFunctionName()
        };
    }

    // Return the validation results.
    return validationResult;
}; */

/* export const validateDeleteEmailRequest = (deleteEmailData) => {
    // Validate the basic parameters request.
    const validationResult = validateManageEmailRequest(deleteEmailData);

    // Check to validate validationResult existence.
if (!validationResult) {
        // Set the error console with the error's relevant information data.
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.MISSING,
            parameters: ['validationResult'],
            functionName: getFunctionName()
        };
    }

    // Return the validation results.
    return validationResult;

    // Check if there is an error from the basic validation.
        if (!validationResult.errorToConsole) {

            // No need for additional action - Return the validation results.
            return validationResult;
        }
}; */

/* isComponentMounted: PropTypes.bool.isRequired,
    isGenerateFakeEmails: PropTypes.bool.isRequired,
isGenerateFakeEmails: state.search.isGenerateFakeEmails, */

        /*     onSearchStoreFakeEmailsStart: PropTypes.func.isRequired, */

/*         onSearchStoreFakeEmailsStart: () => {
            return dispatch(actions.onSearchStoreFakeEmailsStart());
        }, */

/* }
if (!props.searchKeyInputValue && props.isGenerateFakeEmails) { */

/* {
    "api_base_url": "https://burger-builder-84921.firebaseio.com/",
    "api_base_user_authentication_url": "https://www.googleapis.com/identitytoolkit/v3/relyingparty/",
    "api_base_user_authentication_key": "AIzaSyAPZZY47KGG2aNteQ3p9V8N5o8jy7K5znE",
    "api_user_authentication_token_milliseconds_count": 1000,
    "email": "orassayag@gmail.com",
    "creator": "Or Assayag",
    "icons_url": "https://icons8.com/",
    "icons_name": "icons8",
    "application_creation_year": 2018,
    "maximum_user_emails_total_count_limit": 60,
    "email_searcher_init": "email_searcher",
    "email_default_culture": "en",
    "isVerifyFakeEmailsOnDatabase": "true"
} */

/* {
    "api_base_url": "https://burger-builder-84921.firebaseio.com/",
    "api_base_user_authentication_url": "https://www.googleapis.com/identitytoolkit/v3/relyingparty/",
    "api_base_user_authentication_key": "AIzaSyAPZZY47KGG2aNteQ3p9V8N5o8jy7K5znE",
    "api_user_authentication_token_milliseconds_count": 1000,
    "email": "orassayag@gmail.com",
    "creator": "Or Assayag",
    "icons_url": "https://icons8.com/",
    "icons_name": "icons8",
    "application_creation_year": 2018,
    "maximum_user_emails_total_count_limit": 60,
    "email_searcher_init": "email_searcher",
    "email_default_culture": "en",
    "isVerifyFakeEmailsOnDatabase": "true"
} */

/* 
{
    "api_base_url": "https://burger-builder-84921.firebaseio.com/",
    "api_base_user_authentication_url": "https://www.googleapis.com/identitytoolkit/v3/relyingparty/",
    "api_base_user_authentication_key": "AIzaSyAPZZY47KGG2aNteQ3p9V8N5o8jy7K5znE",
    "api_user_authentication_token_milliseconds_count": 1000,
    "email": "orassayag@gmail.com",
    "creator": "Or Assayag",
    "icons_url": "https://icons8.com/",
    "icons_name": "icons8",
    "application_creation_year": 2018,
    "maximum_user_emails_total_count_limit": 200,
    "email_searcher_init": "email_searcher",
    "email_default_culture": "en",
    "isVerifyFakeEmailsOnDatabase": "true"
} */

/* import { getEnvironment } from '../../utils/coreUtils';
const environment = getEnvironment();
let applicationSettings = null;
import(`./settings.${environment}.js`).then( 
    src => { return export default applicationSettings }
    );
console.log(applicationSettings);
export default applicationSettings; */

/* const { getEnvironment } = require('../../utils/coreUtils.js');
const applicationSettings = require(`./settings.${getEnvironment()}.js`).default;
export default applicationSettings; */

/* import { getEnvironment } from '../../utils/coreUtils';
const environment = getEnvironment();
let applicationSettings = null;
import(`./settings.${environment}.js`).then( src => applicationSettings = src.default );
console.log(applicationSettings);
export default applicationSettings; */

/* const { getEnvironment } = require('../../utils/coreUtils.js');
const applicationSettings = require(`./settings.${getEnvironment()}.js`).default;
export default applicationSettings; */

/* {
    "api_base_url": "https://burger-builder-84921.firebaseio.com/",
    "api_base_user_authentication_url": "https://www.googleapis.com/identitytoolkit/v3/relyingparty/",
    "api_base_user_authentication_key": "AIzaSyAPZZY47KGG2aNteQ3p9V8N5o8jy7K5znE",
    "api_user_authentication_token_milliseconds_count": 1000,
    "email": "orassayag@gmail.com",
    "creator": "Or Assayag",
    "icons_url": "https://icons8.com/",
    "icons_name": "icons8",
    "application_creation_year": 2018,
    "maximum_user_emails_total_count_limit": 60,
    "email_searcher_init": "email_searcher",
    "email_default_culture": "en",
    "isVerifyFakeEmailsOnDatabase": "true"
} */

/*         // Check the validity of the max number of emails from the settings file config.
        // Check the validity of the maximum total count limit.
        const maximumUserEmailsTotalCountLimit = getNumber({
            targetNumber: settings.maximum_user_emails_total_count_limit,
            defaultNumber: 200
        }); */

/* user-emails
logout
user-authentication
/
* */

/* import userAuthenticationShape from '../../modals/proptypes/userAuthentication';
import userEmailsShape from '../../modals/proptypes/userEmails';
import manageEmailShape from '../../modals/proptypes/manageEmail'; */
/* import { generateFakeEmails } from '../../utils/fakeDataUtils'; */
/* import userAuthenticationShape from '../../modals/proptypes/userAuthentication';
import userEmailsShape from '../../modals/proptypes/userEmails';
import emailShape from '../../modals/proptypes/email';
import searchOptionsShape from '../../modals/proptypes/searchOptionsShape';
import manageEmailShape from '../../modals/proptypes/manageEmail'; */

/* import logicSettings from '../../settings/logic/logicSettings'; */
/* import { updateObject } from '../../utils/coreUtils'; */

// This action is called when the search page loads to generate some inner sagas
// to generate fake emails or to verify the existence of fake emails.
export const onSearchOnLoadStart = () => {
    return {
        type: actionTypes.SEARCH_ON_LOAD_START
    };
};

searchOnLoadStartSaga


apiBaseUrl
apiBaseUserAuthenticationUrl
apiBaseUserAuthenticationKey
apiUserAuthenticationTokenMillisecondsCount
creatorEmail
creatorName
iconsUrl
iconsName
applicationCreationYear
maximumUserEmailsTotalCountLimit
emailSearcherInit
emailDefaultCulture
isGenerateFakeEmails
isVerifyFakeEmailsExistsOnDatabase

{
    "api_base_url": "https://burger-builder-84921.firebaseio.com/",
    "api_base_user_authentication_url": "https://www.googleapis.com/identitytoolkit/v3/relyingparty/",
    "api_base_user_authentication_key": "AIzaSyAPZZY47KGG2aNteQ3p9V8N5o8jy7K5znE",
    "api_user_authentication_token_milliseconds_count": 1000,
    "email": "orassayag@gmail.com",
    "creator": "Or Assayag",
    "icons_url": "https://icons8.com/",
    "icons_name": "icons8",
    "application_creation_year": 2018,
    "maximum_user_emails_total_count_limit": 60,
    "email_searcher_init": "email_searcher",
    "email_default_culture": "en",
    "isVerifyFakeEmailsOnDatabase": "true"
}

import { getFunctionName } from '../../../utils/coreUtils';

searchErrorAddEmailSaga

getFunctionName()


import { createEnum } from '../../utils/coreUtils';

// This enum routes define a dictionary of all the routes.
const Routes = createEnum(new Map([
    ['USER_EMAILS', 'user-emails'],
    ['USER_AUTHENTICATION', 'user-authentication'],
    ['LOGOUT', 'logout'],
    ['SEARCH', '/'],
    ['NOT_FOUND', '*']
]));

path={`/${Routes.USER_EMAILS}`} 

export default Routes;

user-emails
logout
user-authentication
/
*


error_general
user_authentication_page_error_general
search_options_general_error
search_bar_error_general
add_email_modal_error_general
delete_email_modal_error_general

    "user_authentication_page_error_general": "Oops... something went wrong :(",
    "search_options_general_error": "Something went wrong, please try again later :(",
    "search_bar_error_general": "Something went wrong, please try again later :(",
    "add_email_modal_error_general": "Failed to add the email, please try again later :(",
    "delete_email_modal_error_general": "Failed to delete the email, please try again later :("


    /*     state = { */
    /*         isUserAuthenticated: true, */
    /*         isComponentMounted: false, */
    /*         isLoadingEmails: true,
            isEmailsError: false, */
    /*         modalErrorMessage: null, */
    /*         isShowModal: false,
            isLoadingModal: false */
    /*         emailsNavigation: {
                emailsCountPerPage: 10,
                currentPageNumber: 1,
                totalPagesCount: null
            }, */
    /*         deleteEmail: {
                emailId: null,
                email: null
                // ToDo: Add error message when unexpected error occured.
                // Bring the "modalErrorMessage" to here.
            } */
    /*         emailsDataBase: [], // Only for development to simulate an email database - In production we won't need it.
            totalEmailsCount: null,
            deletedEmailsCount: 0,
            emails: [] */
    /*     }; */

    /*     getEmailsTimeOut = null; */     


    /*     pagesCountToShow = 4; */
   /*         this.setState({ isComponentMounted: true }, () => {
                    if (this.state.isComponentMounted) {
                        this.getEmailsToDisplay();
                    }
                }); */    

/*     // To avoid any leak of memory during the first load of getEmailsToDisplay method, while the user can redirect to another page while 
        // settimeout is still running (in production by axios), need to clear the timeout (in development).
        componentWillUnmount() {
            if (this.getEmailsTimeOut) {
                window.clearTimeout(this.getEmailsTimeOut);
            }
        } */  

  /*     // When the user clicks on the icon next to each email row on the search page (the home page)
    // The modal will be open with all relevant details that are about to be added to users' list.
    export function* searchAddEmailModalToggleStartSaga(action) {
        // Validate existence of action parameters. If one of the parameters are
        // missing - User clicked on the X on add email modal, or something is wrong, 
        // don't display the modal to the user. Either cases - Hide the add email modal window.
        if (!action.toggleAddEmailModalData.emailId || !action.toggleAddEmailModalData.emails || action.toggleAddEmailModalData.emails.length <= 0) {
            yield put(actions.onSearchModalToggleSuccess({
                isToggle: false,
                isShowModal: false,
                authenticationRequiredModalType: null
            }));
            return;
        }
    
        // Create the template to update the state.
        const addEmailData = {
            emailId: null,
            email: null,
            errorMessage: null
        };
    
        // Get the emailId selected by the user. Then, validate that the id exists.
        // If not - Something is wrong, don't display the modal to the user.
        addEmailData.emailId = action.toggleAddEmailModalData.emailId.substr(6);
        if (!addEmailData.emailId) {
            yield put(actions.onSearchModalToggleSuccess({
                isToggle: false,
                isShowModal: false,
                authenticationRequiredModalType: null
            }));
            return;
        }
    
        // Get the specific email row from the email's list by the fetched Id.
        // If the email row does not exist by the Id - Something is wrong, don't display the modal to the user.
        const email = action.toggleAddEmailModalData.emails.find(item => item.emailId === addEmailData.emailId);
        if (!email) {
            yield put(actions.onSearchModalToggleSuccess({
                isToggle: false,
                isShowModal: false,
                authenticationRequiredModalType: null
            }));
            return;
        }
    
        // Check that the email was not already added to the user's emails list. If so - Don't do nothing.
        // If the email is already added and clicked on again - No need to do nothing.
        if (email.emailActionType && email.emailActionType === enums.EmailActionType.ADDED) {
            yield put(actions.onSearchModalToggleSuccess({
                isToggle: false,
                isShowModal: false,
                authenticationRequiredModalType: null
            }));
            return;
        }
    
        // Set the email address from the selected email row to the success data.
        addEmailData.email = email.emailAddress;
    
        // Call the success toggle action to raise up the add email modal window.
        yield put(actions.onSearchAddEmailModalToggleSuccess({
            isShowModal: true,
            addEmail: addEmailData
        }));
    } */      


  /*         if (!e.currentTarget.dataset.id) {
                    throw new Error(translate.error_not_found.replace('#param#', 'emailId'));
                }
        
                const emailData = {
                    emailId: null,
                    emailRow: null,
                    isShowDeleteEmailModal: true
                };
        
                if (e.currentTarget.dataset.id) {
                    emailData.emailId = e.currentTarget.dataset.id.substr(6);
                    if (!emailData.emailId) {
                        throw new Error(translate.error_not_found.replace('#param#', 'emailId'));
                    }
                }
        
                emailData.emailRow = this.state.emails.find(email => email.id === emailData.emailId);
                if (emailData.emailRow) {
                    // Check that the email was not already deleted from user's emails list.
                    if (emailData.emailRow.emailActionType === enums.EmailActionType.DELETED) {
                        emailData.isShowDeleteEmailModal = false;
                    }
                }
                else {
                    emailData.isShowDeleteEmailModal = false;
                }
        
                if (emailData.isShowDeleteEmailModal) {
                    this.manageDeleteEmail({
                        emailId: emailData.emailId,
                        email: emailData.emailRow.email,
                        isToggleModal: true
                    });
                }
                else {
                    this.manageDeleteEmail({
                        emailId: null,
                        email: null,
                        isShowModal: false
                    });
                } */   


 /*     manageDeleteEmail = (data) => {
    
            // Validate existence parameter.
            if (!data) {
                throw new Error(translate.error_missing.replace('#params#', 'data'));
            }
    
            // Create data to update.
            const updatedDeleteEmail = updateObject({
                oldObject: this.state.deleteEmail,
                updatedProperties: {
                    emailId: data.emailId,
                    email: data.email
                }
            });
    
            this.setState((prevState) => {
                return {
                    isShowModal: data.isToggleModal ? !prevState.isShowModal : data.isShowModal,
                    deleteEmail: updatedDeleteEmail
                };
            });
        } */       

 /*         const state = this.state;
        
                // Check that the element that was clicked is not the X icon.
                if (!emailId || e.target.className === 'fa fa-close') {
                    return;
                }
        
                // Delete email from user's emails list.
                // Make a shallow copy of the emails.
                const emails = [...state.emails];
        
                // Get the index of the email.
                const emailToUpdateIndex = emails.findIndex(email => email.id === emailId);
                if (emailToUpdateIndex < 0) {
                    throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
                }
                emails[emailToUpdateIndex].isMoreInformationMode = !emails[emailToUpdateIndex].isMoreInformationMode;
                this.setState({ emails: emails }); */    

/*     if (!basicEmailValidationData || !basicEmailValidationData.emails || basicEmailValidationData.emails.length <= 0 ||
            !basicEmailValidationData.userAuthentication || !basicEmailValidationData.userAuthentication.userId ||
            !basicEmailValidationData.userAuthentication.userToken || !basicEmailValidationData.userAuthentication.isUserAuthenticated() ||
            !basicEmailValidationData.emailId) { */        

/*         const state = this.state;
        
                // ToDo: Add logic of delete email from user's emails.
                if (!state.deleteEmail.emailId) {
                    throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
                }
        
                // Set the state.
                this.setState({ isLoadingModal: true });
        
                // Delete email from user's emails list.
                // Make a shallow copy of the emails.
                const emails = [...state.emails];
        
                // Get the index of the email.
                const emailToUpdateIndex = emails.findIndex(email => email.id === state.deleteEmail.emailId);
                if (emailToUpdateIndex < 0) {
                    throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
                }
        
                // Simulate loading until real ajax call.
                setTimeout(() => {
                    this.setState({ isLoadingModal: false });
        
                    // Determine if to simulate error on deleting the email.
                    let deleteError = false;
                    if (deleteError) {
                        this.setState({ modalErrorMessage: translate.delete_email_modal_error_general });
                        setTimeout(() => {
                            this.resetDeleteEmail();
                            this.setState({ modalErrorMessage: null });
                        }, 1000);
                    }
                    else {
                        // Reset all delete email's state properties.
                        this.resetDeleteEmail();
        
                        setTimeout(() => {
                            // Update the email.
                            emails[emailToUpdateIndex].emailActionType = enums.EmailActionType.DELETED;
        
                            // There is a logic to refresh the page each 3 deletes, and check for emails left in a pager page.
                            // If users don't have pager (less than a logic settings number of emails), no need for the logic.
                            if (state.totalEmailsCount >= logicSettings.minimumEmailsCountToShowPager) {
                                // In real world data base you wouldn't delete a row database - Just change the state of active field to false, for statistics.
                                // Will determine which callback to run after setState completes.
                                let executeFunc = this.initRender;
        
                                this.setState(prevState => {
                                    // Since delete email don't effect on pager / counter, we want to initialize the page after some time of deleting emails.
                                    // So the logic is that after a number from logic settings is exceeded, deletes without refreshing the page, there will be a render of the page automatically.
                                    // This logic applies only if the user has more than the total number from logic settings of emails.
                                    let updatedDeletedEmailsCount = prevState.deletedEmailsCount + 1;
                                    if (updatedDeletedEmailsCount > (logicSettings.emailsCountToRefreshPage - 1) || (prevState.emails.length - 1) <= 0) {
                                        executeFunc = this.getEmailsToDisplay;
                                    }
        
                                    // Also, check if after delete there are still active emails remains in the
                                    // page, if not, refresh the page, and reset the current page to start. 
                                    // Also, if the number of emails left does not fit the pager, render the page again.
                                    let updatedEmailsNavigation = prevState.emailsNavigation;
                                    const emailsCount = state.emails.filter(email => {
                                        return email.emailActionType !== enums.EmailActionType.DELETED;
                                    });
        
                                    if (emailsCount.length <= 0 ||
                                        (state.emails.length % state.emailsNavigation.emailsCountPerPage <= 0 && prevState.emailsNavigation.currentPageNumber === 1)) {
                                        executeFunc = this.getEmailsToDisplay;
        
                                        // Make a shallow copy of the email's navigation and reset the current page number to start.
                                        updatedEmailsNavigation = updateObject({
                                            oldObject: state.emailsNavigation,
                                            updatedProperties: {
                                                currentPageNumber: 1
                                            }
                                        });
                                    }
        
                                    return {
                                        totalEmailsCount: prevState.totalEmailsCount - 1,
                                        deletedEmailsCount: updatedDeletedEmailsCount,
                                        emailsNavigation: updatedEmailsNavigation,
                                        emails: emails
                                    };
                                }, () => { executeFunc(); });
                            }
                            else {
                                // Update the state and the titles.
                                this.setState(prevState => {
                                    return {
                                        totalEmailsCount: prevState.totalEmailsCount - 1,
                                        emails: emails
                                    };
                                }, () => { this.initRender(); });
                            }
                        }, 100);
                    }
                }, 1000); */       

 /*         this.resetDeleteEmail(); */     

   /*         // Check that value exists.
                if (!e.target.value) {
                    throw new Error(translate.error_missing.replace('#params#', 'counter number'));
                }
        
                // Check that the counter value is a number.
                const updatedCounter = Number(e.target.value);
                if (isNaN(updatedCounter)) {
                    throw new Error(translate.error_invalid.replace('#params#', 'counter number'));
                }
        
                const state = this.state;
        
                // Check that the counter value is different from the current counter value.
                if (state.emailsNavigation.emailsCountPerPage === updatedCounter) {
                    return;
                }
        
                // Make a shallow copy of the email's navigation and reset the current page number to start.
                const updatedEmailsNavigation = updateObject({
                    oldObject: state.emailsNavigation,
                    updatedProperties: {
                        currentPageNumber: 1,
                        emailsCountPerPage: updatedCounter
                    }
                });
        
                // Update the navigation state and render emails's list again.
                this.setState({ emailsNavigation: updatedEmailsNavigation }, () => this.getEmailsToDisplay()); */      

  /*         // Validate the page number / value.
                if (!pageNumber) {
                    throw new Error(translate.error_missing.replace('#params#', 'pageNumber'));
                }
        
                const state = this.state;
        
                // Check if the clicked page is not the current page.
                if (state.emailsNavigation.currentPageNumber === pageNumber) {
                    return;
                }
        
                // Check which type of page actually clicked.
                switch (pageNumber) {
                    case enums.PagerLink.NEXT:
                        // Check if there is an option to go next or the current page is the last page.
                        if (state.emailsNavigation.currentPageNumber === state.emailsNavigation.totalPagesCount) {
                            return;
                        }
                        pageNumber = state.emailsNavigation.currentPageNumber + 1;
                        break;
                    case enums.PagerLink.PREVIOUS:
                        // Check if there is an option to go previous or the current page is the first page.
                        pageNumber = state.emailsNavigation.currentPageNumber - 1;
                        if (pageNumber <= 0) {
                            return;
                        }
                        break;
                    default:
                        // If not a number (except next or previous) - throw an exception.
                        if (isNaN(pageNumber)) {
                            throw new Error(translate.error_invalid.replace('#params#', 'pageNumber'));
                        }
        
                        // Check that the page number is on the limits.
                        if (pageNumber <= 0 || pageNumber > state.emailsNavigation.totalPagesCount) {
                            throw new Error(translate.error_invalid.replace('#params#', 'pageNumber'));
                        }
                        break;
                }
        
                // Make a shallow copy of the email's navigation.
                const updatedEmailsNavigation = updateObject({
                    oldObject: state.emailsNavigation,
                    updatedProperties: {
                        currentPageNumber: pageNumber
                    }
                });
        
                // Update the navigation state and render emails's list again.
                this.setState({ emailsNavigation: updatedEmailsNavigation }, () => this.getEmailsToDisplay()); */  

  /*     getEmailsToDisplay = () => {
            const state = this.state;
    
            // All relevant data stored for this function.
            const emailsData = {
                emailsDataBase: null,
                totalEmailsCount: 0,
                totalPagesCount: 0,
                updatedEmailsNavigation: null,
                indexStart: 0,
                indexEnd: 0,
                emails: null
            };
    
            // Set loader to be on before starting the operation.
            this.setState({ isLoadingEmails: true });
    
            // Get emails from the database (fake in development) if this is the first time of rendering the page.
            // Also, with the current result of the emails, get the total number of emails.
            if (!state.emailsDataBase || state.emailsDataBase.length <= 0) {
                emailsData.emailsDataBase = generateFakeEmails({
                    emailsCount: 24,
                    emailType: enums.EmailType.FAKE
                });
                emailsData.totalEmailsCount = emailsData.emailsDataBase.length;
                this.setState({
                    totalEmailsCount: emailsData.totalEmailsCount,
                    emailsDataBase: emailsData.emailsDataBase
                });
            }
            else {
                emailsData.totalEmailsCount = state.totalEmailsCount;
    
                // If already loaded before, display only the emails 
                // that are not deleted already from the database.
                emailsData.emailsDataBase = state.emailsDataBase.filter(email => {
                    return email.emailActionType !== enums.EmailActionType.DELETED;
                });
            }
    
            // Calculate how many pages to show in pager.
            emailsData.totalPagesCount = Number(emailsData.totalEmailsCount / state.emailsNavigation.emailsCountPerPage);
            if (Number(emailsData.totalEmailsCount % state.emailsNavigation.emailsCountPerPage) > 0) {
                emailsData.totalPagesCount++;
            }
    
            // Make a shallow copy of the email's navigation.
            emailsData.updatedEmailsNavigation = updateObject({
                oldObject: state.emailsNavigation,
                updatedProperties: {
                    totalPagesCount: Math.floor(emailsData.totalPagesCount)
                }
            });
    
            // Calculate the indexes to slice from the database.
            emailsData.indexStart = (state.emailsNavigation.currentPageNumber - 1) * state.emailsNavigation.emailsCountPerPage;
            emailsData.indexEnd = emailsData.indexStart + state.emailsNavigation.emailsCountPerPage;
    
            // Slice the emails from the database by the calculated section.
            emailsData.emails = [...emailsData.emailsDataBase].slice(emailsData.indexStart, emailsData.indexEnd);
    
            // Update all states and reset deletedEmailsCount to avoid refreshing the page when less then 3 emails are deleted.
            this.getEmailsTimeOut = setTimeout(() => {
                this.setState({
                    emails: emailsData.emails,
                    totalEmailsCount: emailsData.totalEmailsCount,
                    emailsNavigation: emailsData.updatedEmailsNavigation,
                    deletedEmailsCount: 0,
                    isLoadingEmails: false
                });
            }, 500);
        } */
    /* 
        resetDeleteEmail = () => {
            this.manageDeleteEmail({
                emailId: null,
                email: null,
                isShowModal: false
            });
        } */


onTouchStart={listener, options}   

 if (!basicEmailValidationData || !basicEmailValidationData.emails || basicEmailValidationData.emails.length <= 0 ||
        !basicEmailValidationData.userAuthentication || !basicEmailValidationData.userAuthentication.userId ||
        !basicEmailValidationData.userAuthentication.userToken || !basicEmailValidationData.userAuthentication.isUserAuthenticated() ||
        !basicEmailValidationData.emailId) {


        // Call the delete email saga to delete the
        // email from the database and the state.
        props.onUserDeleteEmailProcessStart({
            userAuthentication: props.userAuthentication,
            emails: props.userEmails.userEmailsList,
            emailId: props.deleteEmail.emailId,
            beforeDeleteUserEmailsTotalCount: props.userEmails.userEmailsTotalCount,
            beforeDeleteUserEmailsDeletedCount: props.userEmails.userEmailsDeletedCount,
            beforeDeleteUserEmailsCurrentPageNumber: props.userEmails.userEmailsCurrentPageNumber
        });

        // Call the delete email saga to delete the
        // email from the database and the state.
        props.onUserDeleteEmailProcessStart({
            userAuthentication: props.userAuthentication,
            emails: props.userEmails.userEmailsList,
            emailId: props.deleteEmail.emailId,
            beforeDeleteUserEmailsTotalCount: props.userEmails.userEmailsTotalCount,
            beforeDeleteUserEmailsDeletedCount: props.userEmails.userEmailsDeletedCount
        });

// Components parameter and functions PropTypes validations.
TextBox.propTypes = {
    inputType: PropTypes.string.isRequired,
    classType: PropTypes.string,
    placeHolder: PropTypes.string.isRequired,
    errorMessage: PropTypes.string,
    onChange: PropTypes.func,
    autoComplete: PropTypes.bool.isRequired
};  

  // Call the success toggle action to raise up the delete email modal window.
    yield put(actions.onUserDeleteEmailModalToggleSuccess({
        isShowModal: true,
        deleteEmail: validationResult
    }));

toggleDeleteEmailModalData

toggleManageEmailModalData       

 minimumNumber: randomTextData.minimumStringsCount,
        maximumNumber: randomTextData.maximumStringsCount

            minimumNumber: randomTextData.minimumStringLength,
            maximumNumber: randomTextData.maximumStringLength   

    // The minimum length to create a single string (random word).
    minimumStringLength: 5,

    // The maximum length to create a single string (random word).
    maximumStringLength: 15,     

// Stop any further actions.

// This function is called after an email was added / deleted from / to the user's emails list, and it creates a 
// copy of the emails list and updates the relevant email to be marked as added / deleted, to 
// display the user that the email was added / deleted.
export const setManageEmailAction = (manageEmailData) => {
    // Validate the existence and the validity of the parameters. If some of the parameters are invalid - Don't do nothing.
    if (!manageEmailData || !manageEmailData.emails || manageEmailData.emails.length <= 0 ||
        !manageEmailData.emailId || !manageEmailData.emailAddress) {
        return null;
    }

    // Make a copy of the emails.
    const updatedEmails = copyObjectsArray(manageEmailData.emails);

    // Make the index of the relevant email. If the email is not found in the list - Something went wrong - Don't do nothing.
    const emailToUpdateIndex = updatedEmails.findIndex(email => email.emailId === manageEmailData.emailId);
    if (emailToUpdateIndex < 0) {
        return null;
    }

    // Update the email and return the updated emails list.
    updatedEmails[emailToUpdateIndex].emailActionType = manageEmailData.emailActionType;
    return updatedEmails;
};

basicEmailValidationData

// This reducer is called when the user adds the email successfully to his 
// emails list and to close the window after saving the email to his emails list
// Or cancel the adding email process.
export const onSearchAddEmailModalToggleSuccess = (state, action) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isShowModal: action.addEmailData.isShowModal,
            isLoadingModal: false,
            errorMessageModal: null,
            addEmailComments: '',
            addEmail: action.addEmailData.addEmail
        }
    });
};

// This reducer is called when the add email process is finished or 
// cancelled and there is a need to reset the addEmail dynamic object.
export const onSearchAddEmailModalToggleReset = (state) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isShowModal: false,
            // Clone the add email state and update.
            addEmail: updateObject({
                oldObject: state.addEmail,
                updatedProperties: toAddEmail()
            })
        }
    });
};

// Update the error message to state on the add email modal window.
export const onSearchAddEmailProcessError = (state, action) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isLoadingModal: false,
            // Clone the add email state and update.
            addEmail: updateObject({
                oldObject: state.addEmail,
                updatedProperties: {
                    errorMessage: action.errorMessage
                }
            })
        }
    });
};

// Update the loading animation state on the email modal window before calling the API server.
export const onSearchAddEmailProcessPreparation = (state) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isLoadingModal: true,
            // Clone the add email state and update.
            addEmail: updateObject({
                oldObject: state.addEmail,
                updatedProperties: {
                    errorMessage: null
                }
            })
        }
    });
};

// Update the error message inside the modal window after calling the API server.
export const onSearchAddEmailProcessFail = (state, action) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isLoadingModal: false,
            errorMessageModal: action.errorMessageModal
        }
    });
};

// Update the emails list after successfully adding the email process.
export const onSearchAddEmailProcessSuccess = (state, action) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            emails: [...action.emails]
        }
    });
};


export const USER_DELETE_EMAIL_MODAL_TOGGLE_START = 'USER_DELETE_EMAIL_MODAL_TOGGLE_START';
export const USER_DELETE_EMAIL_MODAL_TOGGLE_SUCCESS = 'USER_DELETE_EMAIL_MODAL_TOGGLE_SUCCESS';
export const USER_DELETE_EMAIL_MODAL_TOGGLE_RESET = 'USER_DELETE_EMAIL_MODAL_TOGGLE_RESET';
export const USER_DELETE_EMAIL_PROCESS_START = 'USER_DELETE_EMAIL_PROCESS_START';
export const USER_DELETE_EMAIL_PROCESS_PREPARATION = 'USER_DELETE_EMAIL_PROCESS_PREPARATION';
export const USER_DELETE_EMAIL_PROCESS_ERROR = 'USER_DELETE_EMAIL_PROCESS_ERROR';
export const USER_DELETE_EMAIL_PROCESS_SUCCESS = 'USER_DELETE_EMAIL_PROCESS_SUCCESS';
export const USER_DELETE_EMAIL_PROCESS_FAIL = 'USER_DELETE_EMAIL_PROCESS_FAIL';

old: setAddEmailAdded
new: setManageEmailAction

// When the user clicks on the icon of the plus next to each email row on the search page (the home page)
// The modal will be open with all relevant details that are about to be added to users's list.
export function* searchAddEmailModalToggleStartSaga(action) {
    // Validate existence of action parameters. If one of the parameters are
    // missing - User clicked on the X on add email modal, or something is wrong, 
    // don't display the modal to the user. Either cases - Hide the add email modal window.
    if (!action.toggleAddEmailModalData.emailId || !action.toggleAddEmailModalData.emails || action.toggleAddEmailModalData.emails.length <= 0) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Create the template to update the state.
    const addEmailData = {
        emailId: null,
        email: null,
        errorMessage: null
    };

    // Get the emailId selected by the user. Then, validate that the id exists.
    // If not - Something is wrong, don't display the modal to the user.
    addEmailData.emailId = action.toggleAddEmailModalData.emailId.substr(6);
    if (!addEmailData.emailId) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Get the specific email row from the email's list by the fetched Id.
    // If the email row does not exist by the Id - Something is wrong, don't display the modal to the user.
    const email = action.toggleAddEmailModalData.emails.find(item => item.emailId === addEmailData.emailId);
    if (!email) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Check that the email was not already added to the user's emails list. If so - Don't do nothing.
    // If the email is already added and clicked on again - No need to do nothing.
    if (email.emailActionType && email.emailActionType === enums.EmailActionType.ADDED) {
        yield put(actions.onSearchModalToggleSuccess({
            isToggle: false,
            isShowModal: false,
            authenticationRequiredModalType: null
        }));
        return;
    }

    // Set the email address from the selected email row to the success data.
    addEmailData.email = email.emailAddress;

    // Call the success toggle action to raise up the add email modal window.
    yield put(actions.onSearchAddEmailModalToggleSuccess({
        isShowModal: true,
        addEmail: addEmailData
    }));
}


export const USER_COUNTER_UPDATE_START = 'USER_COUNTER_UPDATE_START';   




 // Validate the existence of parameters. If invalid - Don't do nothing.
    if (!toggleEmailData || !toggleEmailData.userEmails.userEmailsList || toggleEmailData.userEmails.userEmailsList.length <= 0 ||
        !toggleEmailData.emailId || toggleEmailData.e.target.className === 'fa fa-close') {
        return;
    }

export const USER_TOGGLE_EMAIL_MORE_INFORMATION_START = 'USER_TOGGLE_EMAIL_MORE_INFORMATION_START';
export const USER_TOGGLE_EMAIL_MORE_INFORMATION_SUCCESS = 'USER_TOGGLE_EMAIL_MORE_INFORMATION_SUCCESS';   

 moreInfoToggleClickHandler = (emailId, e) => {
        const state = this.state;

        // Check that the element that was clicked is not the X icon.
        if (!emailId || e.target.className === 'fa fa-close') {
            return;
        }

        // Delete email from user's emails list.
        // Make a shallow copy of the emails.
        const emails = [...state.emails];

        // Get the index of the email.
        const emailToUpdateIndex = emails.findIndex(email => email.id === emailId);
        if (emailToUpdateIndex < 0) {
            throw new Error(translate.error_not_found.replace('#param#', `Email ${state.deleteEmail.emailId}`));
        }
        emails[emailToUpdateIndex].isMoreInformationMode = !emails[emailToUpdateIndex].isMoreInformationMode;
        this.setState({ emails: emails });
    }
userEmailsList: PropTypes.arrayOf(email),
userEmailsTotalCount: PropTypes.number.isRequired,
userEmailsCountPerPage: PropTypes.number.isRequired,
userEmailsPagesTotalCount: PropTypes.number.isRequired,
userEmailsCurrentPageNumber: PropTypes.number.isRequired,
userEmailsPagesCountToShow: PropTypes.number.isRequired,
userEmailsDeletedCount: PropTypes.number.isRequired  

export const USER_GET_EMAILS_PROCESS_NO_EMAILS_SUCCESS = 'USER_GET_EMAILS_PROCESS_NO_EMAILS_SUCCESS';
onUserGetEmailsProcessNoEmailsSuccess
onUserGetEmailsProcessFirstLoadPreparation



export const onUserGetEmailsProcessFirstLoadPreparation = (state) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isComponentMounted: true
        }
    });
};

export const onUserGetEmailsProcessNoEmailsSuccess = (state) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            isLoadingEmails: false,
            isEmailsError: false
        }
    });
};


 

export const USER_GET_EMAILS_PROCESS_FIRST_LOAD_PREPARATION = 'USER_GET_EMAILS_PROCESS_FIRST_LOAD_PREPARATION';
onUserGetEmailsProcessFirstLoadPreparation

onUserGetEmailsProcessPreparation  
export const USER_GET_EMAILS_PROCESS_PREPARATION = 'USER_GET_EMAILS_PROCESS_PREPARATION';

  const emailsData = {
        totalEmailsCount: Object.keys(userGetEmailsRequest.emailsDataBase).length,
        emailsCountPerPage: userGetEmailsRequest.updatedCounterValue ? userGetEmailsRequest.updatedCounterValue : userGetEmailsRequest.userEmails.userEmailsCountPerPage,
        currentPageNumber: userGetEmailsRequest.updatedPagerValue ? userGetEmailsRequest.updatedPagerValue : userGetEmailsRequest.userEmails.userEmailsCurrentPageNumber,
        totalPagesCount: 0,
        indexStart: 0,
        indexEnd: 0,
        emails: null
    };  

const getEmailsDataRequest = {
        userAuthentication: userAuthentication,
        userEmails: userEmails,
        isFirstPageLoad: isFirstPageLoad,
        updatedPagerValue: updatedPagerValue,
        updatedCounterValue: updatedCounterValue,
    }

export const USER_GET_EMAILS_PROCESS_SUCCESS = 'USER_GET_EMAILS_PROCESS_SUCCESS';

export const getUserEmails = (userGetEmailsRequest) => {
    // Will hold the final data results.
    // Check if the page number or the count of emails per page has been
    // changed by the user. If so - use the updated configuration
    // for the emails paging to get relevant results.
    const emailsData = {
        totalEmailsCount: Object.keys(userGetEmailsRequest.emailsDataBase).length,
        emailsCountPerPage: userGetEmailsRequest.updatedCounterValue ? userGetEmailsRequest.updatedCounterValue : userGetEmailsRequest.userEmails.userEmailsCountPerPage,
        currentPageNumber: userGetEmailsRequest.updatedPagerValue ? userGetEmailsRequest.updatedPagerValue : userGetEmailsRequest.userEmails.userEmailsCurrentPageNumber,
        totalPagesCount: 0,
        indexStart: 0,
        indexEnd: 0,
        emails: null
    };

    // Calculate how many pages to show in pager.
    emailsData.totalPagesCount = Number(userGetEmailsRequest.totalEmailsCount / emailsData.emailsCountPerPage);
    if (Number(userGetEmailsRequest.totalEmailsCount % emailsData.emailsCountPerPage) > 0) {
        emailsData.totalPagesCount++;
    }

    // Make a floor operation to the pages count.
    emailsData.totalPagesCount = Math.floor(emailsData.totalPagesCount);

    // Calculate the indexes to slice from the database.
    emailsData.indexStart = (emailsData.currentPageNumber - 1) * emailsData.emailsCountPerPage;
    emailsData.indexEnd = emailsData.indexStart + emailsData.emailsCountPerPage;

    // Slice the emails from the database by the calculated section.
    // Note that unfortunately, due to limitations of Firebase REST API we can't do "real" paging of 
    // sending "from" and "take" like in real world applications, so we do the paging programmatically.
    emailsData.emails = [...userGetEmailsRequest.emailsDataBase].slice(emailsData.indexStart, emailsData.indexEnd);

    // Return all updated data to update the userEmails instance and the state.
    return emailsData;
};
  


export const USER_EMAILS_AUTHENTICATION_PROCESS_SUCCESS = 'USER_EMAILS_AUTHENTICATION_PROCESS_SUCCESS';

onUserEmailsAuthenticationLogoutSuccess

user Authentication
userEmails   

Authentication

authentication

AUTHENTICATION
AUTHENTICATION_REQUIRED
authenticationRequired

     userEmailsList: userData.userEmailsList,
        userEmailsTotalCount: userData.userEmailsTotalCount,
        userEmailsCountPerPage: userData.userEmailsCountPerPage,
        userEmailsPagesTotalCount: userData.userEmailsPagesTotalCount,
        userEmailsCurrentPageNumber: userData.userEmailsCurrentPageNumber,
        userEmailsDeletedCount: userData.userEmailsDeletedCount        

// All relevant data stored for this function.
        const emailsData = {
            emailsDataBase: null,
            totalEmailsCount: 0,
            totalPagesCount: 0,
            updatedEmailsNavigation: null,
            indexStart: 0,
            indexEnd: 0,
            emails: null
        };

// All items in this enum represent elements in the search page, 
// and for each of them there is different validation and preferences.
export const SearchElementType = createEnum(new Map([
    ['SEARCH_KEY', 'search-key'],
    ['MODE', 'search-mode'],
    ['COMMENTS', 'comments'],
    ...SearchOptionType
]));

// This enum defines a reference point to scroll to elements in 
// mobile and small devices, once a certain action has taken place.
export const SearchScrollPosition = createEnum(new Map([
    ['RESULTS', 'results'],
    ...SearchOptionType
])); 

   searchOptions: [{
            searchOptionType: enums.SearchElementType.DOMAINS,
            isSearchOptionShow: true,
            mode: enums.SearchOption.INCLUDE,
            value: '',
            errorMessage: null
        },
        {
            searchOptionType: enums.SearchElementType.KEYS,
            isSearchOptionShow: true,
            mode: enums.SearchOption.INCLUDE,
            value: '',
            errorMessage: null
        },
        {
            searchOptionType: enums.SearchElementType.URLS,
            isSearchOptionShow: true,
            mode: enums.SearchOption.INCLUDE,
            value: '',
            errorMessage: null
        }
    ],

// This function validates a given string that exists in an array list of a specific type.
export const validateEnumValue = (validateEnumData) => {
    // Validate existence and validity of the parameters.
    if (!validateEnumData || !validateEnumData.enum || !validateEnumData.value) {
        return false;
    }

    // Check if the value exists within a given array. Return false if not.
    if (Object.values(validateEnumData.enum).indexOf(validateEnumData.value) < 0) {
        return false;
    }
    
    // Return true if the value exists within a given array.
    return true;
};

// This function returns an image source by modal auth type after validation of the auth type modal.
export const getAuthImageSourceByType = (mustAuthModalType) => {
    let imageSrc = null;

    // Check the existence of the parameters
    if (mustAuthModalType) {
        if (Object.values(enums.MustAuthModalType).indexOf(mustAuthModalType) < 0) {
            throw new Error(translate.error_invalid.replace('#params#', 'mustAuthModalType'));
        }
        imageSrc = require(`../assets/img/user-auth-${mustAuthModalType}.png`);
    }
    
    // Return the image source.
    return imageSrc;
};

export const validateEnumValue = (validateEnumData) => {  

  // The default page number count to display in the pager component, in case the user
    // has more than the number in "minimumEmailsCountToShowPager" parameter. For example,
    // if the number here is 4 (which is the default number), the user will see 4 links
    // each time at the pager (only if he has a count that is calculated to contain 4 pages
    // of emails items according to the emails count he selected to display).
    defaultPagesCountToShow: 4,    

const countsArray = [10];
    if (props.totalEmailsCount > 10 && props.totalEmailsCount < 50) {
        countsArray.push(20);
    }
    else if (props.totalEmailsCount >= 50) {
        countsArray.push(20, 50);
    }    


    const result = getEqualLowerNumbers({
            targetArray: [10, 20, 50],
            targetNumber: 20
        });

        console.log(result);

// This function gets an array and a specific number and returns a new 
// array with all the numbers that equal or lower than the given number.
export const getEqualLowerNumbers = (equalLowerNumbersData) => {
    // Check existence and validity of all the given parameters.
    if (!equalLowerNumbersData || !equalLowerNumbersData.targetArray) {
        return null;
    }

    // Return a new array with relevant numbers only.
    return equalLowerNumbersData.targetArray.filter(x => { return x <= equalLowerNumbersData.targetNumber; }).map(c => c);
};

getNumber    

// Will the data to create fake emails
    const generateData = {
        emailsCount: getNumber({
            targetNmuber: logicSettings.fakeEmailsCountToCreate,
            defaultNumber: 20
        }),
        emailType: enums.EmailType.SEARCH
    };

import { getNumber } from '../../../utils/textUtils'; 
   // Get minimum number to display the pager.
    const minimumEmailsCountToShowPager = getNumber({
        targetNumber: logicSettings.minimumEmailsCountToShowPager,
        defaultNumber: 10
    });    


getNumber
    arrayRequiredLength: getNumber({
            targetNumber: logicSettings.searchOptionsArrayCount,
            defaultNumber: 3
        })

import { getNumber } from '../../../utils/textUtils';    
// Get minimum number to display the counter.
    const minimumEmailsCountToShowCounter = getNumber({
        targetNumber: logicSettings.minimumEmailsCountToShowCounter,
        defaultNumber: 10
    });    


// The maximum character length of the password that the user can enter when he registers to the application site.
    maximumUserPasswordLength: 20,

    // The minimum character length of the password that the user can enter when he registers to the application site.
    // The minimum count of emails to display the pager on the bottom of the "my-emails" page.
    minimumEmailsCountToShowPager: 10,

    // The minimum count of emails to display the emails count select dropdown on the top of the "my-emails" page.
    minimumEmailsCountToShowCounter: 10,

// Generate the error message to display to the user after the API call returns an error.
export const getSearchErrorMessage = (error) => {
    // Console the user the error message if needed (For developers).
    console.error(error);

    // Check if the parameter of the error exists. If not, return a general error.
    let errorMessage = translate.search_options_general_error;
    if (!error || !error.response || !error.response.data || !error.response.data.error || !error.response.data.error.message) {
        return errorMessage;
    }

    // Return the error message to the user.
    return errorMessage;
};   

 minimumUserPasswordLength: 10,

maximumUserEmailLength

// This function tries to convert string into number, and if is nan or undefined, return default given number.
export const getNumber = (numberData) => {
    // Check if all parameters exists
    if (!numberData) {
        return;
    }

    // Convert the string to a number.
    const convertedNumber = Number(numberData.targetNumber);

    // Return the calculated result if it is a valid number. If not, return the default number.
    return typeof convertedNumber === 'number' && !isNaN(convertedNumber) && isFinite(convertedNumber) ? convertedNumber : numberData.defaultNumber;
};

            this.userEmailsTotalCount = 0;
            this.userEmailsCountPerPage = 4;
            this.userEmailsPagesTotalCount = 4;
            this.userEmailsCurrentPageNumber = 1;
            this.userEmailsDeletedCount = 0;

// Settings that affect logic, that are related to limits of fields, all over the application site, 
// and due to multiplay times they are needed, it's better to put all of them together
// in one center place.
export const limitSettings = {
    // SEARCH

    // The maximum string character length of the search key in text mode to
    // enter input in the text box of the search bar component.
    maximumTextSearchLength: 100,

    // The maximum string character length of the search key in URL mode to
    // enter input in the text box of the search bar component.
    maximumURLSearchLength: 1500,

    // The maximum total character length of all domain keys that entered in 
    // the search option of domain keys textarea in the search option panel.
    maximumDomainsLength: 300,

    // The maximum total charectes length of all email keys that entered in 
    // the search option of email keys textarea in the search option panel.
    maximumKeysLength: 300,

    // The maximum total character length of all URLs that entered in 
    // the search option of URLs textarea in the search option panel.
    maximumURLSLength: 1000,

    // EMAIL

    // The maximum characters of email address within an Email class 
    // that allowed it to be created.
    maximumEmailAddressLength: -1,

    // The maximum character of URL within an Email class 
    // that allows it to be created.
    maximumEmailLinkLength: -1,

    // The maximum characters of the search key within an Email class 
    // that allowed it to be created.
    maximumEmailSearchKey: -1,

    // The maximum characters of comments within an Email class 
    // that allowed to be created.
    maximumEmailComments: -1

    // USER
};

import settings from '../settings/application/settings';

/* // Settings to fake generated data.
const settings = {
    stringArray: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    domainsArray: ['gmail.com', 'hotmail.com', 'outlook.com', 'icloud.com', 'yahoo.com', 'aol.com'],
    linkEndsArray: ['com', 'org', 'net', 'int', 'edu', 'gov', 'mil'],
    searchEngineArray: Object.values(enums.SearchEngine),
    idStringLength: 10,
    minimumEmailLength: 5,
    maximumEmailLength: 20,
    minimumLinkLength: 10,
    maximumLinkLength: 30,
    minimumDate: new Date(2012, 1, 1),
    minimumStringLength: 5,
    maximumStringLength: 15,
    minimumSearchKeyStringsCount: 2,
    maximumSearchKeyStringsCount: 5,
    minimumCommentsStringsCount: 5,
    maximumCommentsStringsCount: 15
}; */


const dataArray = new Map([
    [enums.SearchMode.TEXT,
        {
            searchOptionType: enums.SearchElementType.TEXT,
            emptyErrorText: translate.search_bar_error_empty_search_key,
            validationFunction: validationUtils.validateSearchKey,
            errorValidationText: translate.search_bar_error_alphanumeric,
            maximumCharactersCount: 100,
            maximumCharactersErrorText: translate.search_bar_search_key_error_length_exceeds
        }
    ],
    [enums.SearchMode.URL,
        {
            searchOptionType: enums.SearchElementType.URL,
            emptyErrorText: translate.search_bar_error_empty_url,
            validationFunction: validationUtils.validateUrl,
            errorValidationText: translate.search_bar_error_url,
            maximumCharactersCount: 1500,
            maximumCharactersErrorText: translate.search_bar_url_error_length_exceeds
        }
    ],
    [enums.SearchElementType.DOMAINS,
        {
            searchOptionType: enums.SearchElementType.DOMAINS,
            validationFunction: validationUtils.validateEmailDomains,
            errorValidationText: translate.search_bar_email_domains_invalid_input,
            maximumCharactersCount: 300,
            maximumCharactersErrorText: translate.search_bar_email_domains_error_length_exceeds
        }
    ],
    [enums.SearchElementType.KEYS,
        {
            searchOptionType: enums.SearchElementType.KEYS,
            validationFunction: validationUtils.validateEmailKeys,
            errorValidationText: translate.search_bar_email_keys_invalid_input,
            maximumCharactersCount: 300,
            maximumCharactersErrorText: translate.search_bar_email_keys_error_length_exceeds
        }
    ],
    [enums.SearchElementType.URLS,
        {
            searchOptionType: enums.SearchElementType.URLS,
            validationFunction: validationUtils.validateUrlDomains,
            errorValidationText: translate.search_bar_url_domains_invalid_input,
            maximumCharactersCount: 1000,
            maximumCharactersErrorText: translate.search_bar_url_domains_error_length_exceeds
        }
    ],
    [enums.SearchElementType.COMMENTS,
        {
            searchOptionType: enums.SearchElementType.COMMENTS,
            validationFunction: validationUtils.validateAddEmailComments,
            errorValidationText: translate.add_email_modal_error_invalid_comments,
            maximumCharactersCount: 300,
            maximumCharactersErrorText: translate.add_email_modal_error_comments_length_exceeds
        }
    ]
]);

SearchMode.TEXT,            
maximumCharactersCount: 100,


        this.emailAddress = emailData.emailAddress;
        this.emailLink = emailData.emailLink;
        this.emailSearchKey = emailData.emailSearchKey;
        this.emailComments = emailData.emailComments;



/*     yield put(actions.onSearchAddEmailModalToggleSuccess({
        isShowModal: false,
        addEmail: {
            emailId: null,
            email: null,
            errorMessage: null
        }
    })); */

/*     yield put(actions.onSearchAddEmailModalToggleSuccess({
        isShowModal: false,
        addEmail: {
            emailId: null,
            email: null,
            errorMessage: null
        }
    })); */    

if (props.mustAuthModalType) {
        if (Object.values(enums.MustAuthModalType).indexOf(props.mustAuthModalType) < 0) {
            throw new Error(translate.error_invalid.replace('#params#', 'mustAuthModalType'));
        }
        imageSrc = require(`../../../assets/img/user-auth-${props.mustAuthModalType}.png`);
    }


/*     if (Object.values(enums.UserAuthModeType).indexOf(action.userAuthMode) < 0) {
        yield call(userAuthErrorSaga, {
            errorType: enums.ErrorType.INVALID,
            errorParameters: ['userAuthMode']
        });
        return;
    } */

/*     if (Object.values(enums.EmailType).indexOf(email.emailType) < 0) {
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.INVALID,
            parameters: ['emailActionType'],
            errorErrorType: 'emailActionType'
        };
        return validationResult;
    } */

/*     if (Object.values(enums.SearchEngine).indexOf(email.emailSearchEngine) < 0) {
        validationResult.errorToConsole = {
            errorType: enums.ErrorType.INVALID,
            parameters: ['emailSearchEngine'],
            errorErrorType: 'emailSearchEngine'
        };
        return validationResult;
    }
 */       

 if (!validateEnumValue({
                enum: enums.MustAuthModalType,
                value: action.toggleModalData.mustAuthModalType
            })) {
            return;
        } 

   /* 
        if (Object.values(enums.SearchMode).indexOf(action.searchModeData.newSearchMode) < 0) {
            yield call(searchOptionErrorSaga, {
                errorType: enums.ErrorType.INVALID,
                errorParameters: ['newSearchMode']
            });
            return;
        } */

/*         if (Object.values(enums.MustAuthModalType).indexOf(action.toggleModalData.mustAuthModalType) < 0) {
            return;
        } */

/*     // Manually validate parameters just in case.
    if (!props.searchOptions || !props.searchMode || !validateArray({
        array: props.searchOptions,
        arrayLength: 3
    })) {
        throw new Error(translate.error_missing.replace('#params#', 'searchOptions or searchMode'));
    } */


// Validate that given value is an array with a specific length. This function is created 
// since to the current production development, so Proptypes don't have validation on array's length.
export const validateArray = (arrayData) => {
    // Check for existence and validity of the parameters.
    if (!arrayData || !arrayData.array || !arrayData.arrayLength || isNaN(arrayData.arrayLength)) {
        return false;
    }

    // Check for type of array with specific count.
    if (!Array.isArray(arrayData.array) || arrayData.array.length !== arrayData.arrayLength) {
        return false;
    }

    // Return calculated result.
    return true;
};

/* // Validate the html button tag type.
export const validateButtonType = (buttonType) => {
    // Check for existence of the parameter.
    if (!buttonType) {
        return false;
    }

    // Return calculated result.
    return ['button', 'submit'].indexOf(buttonType) > -1;
};

// Validate the html input tag type.
export const validateInputType = (inputType) => {
    // Check for existence of the parameter.
    if (!inputType) {
        return false;
    }

    // Return calculated result.
    return ['text', 'email', 'password'].indexOf(inputType) > -1;
}; */    

// Manually validate parameters just in case.
    if (!props.buttonType || !props.classType || !props.iconType || !props.buttonTitle) {
        throw new Error(translate.error_missing.replace('#params#', 'buttonType or classType or iconType or buttonTitle'));
    }

    // Validate that the type of the button is not invalid.
    if (!validateButtonType(props.buttonType)) {
        throw new Error(translate.error_invalid.replace('#params#', 'buttonType'));
    }   

 // Manually validate parameters just in case.
    if (!props.inputType || !props.placeHolder) {
        throw new Error(translate.error_missing.replace('#params#', 'inputType or placeHolder'));
    }

    // Validate that the type of the input is not invalid.
    if (!validateInputType(props.inputType)) {
        throw new Error(translate.error_invalid.replace('#params#', 'inputType'));
    }   

 /*     // Manually validate parameters just in case.
        if (!props.buttonType || !props.title) {
            throw new Error(translate.error_missing.replace('#params#', 'buttonType or title'));
        }
    
        // Validate that the type of the button is not invalid.
        if (!validateButtonType(props.buttonType)) {
            throw new Error(translate.error_invalid.replace('#params#', 'buttonType'));
        } */   

validationUtils

 // Manually validate parameters just in case.
    validateParameters({
        props: props,
        parametersList: ['userAuthMode']
    });

    // Manually validate parameters just in case.
    validateParameters({
        props: props,
        parametersList: ['userAuthMode'],
targetParameter,
validationType
    });

/* // This function gets an array of parameters and throws an exception
// with an error message about which parameters are missing.
const throwParameterErrorException = (errorParametersData) => {
    // Check if the parameters. If one of them is missing - Throw a new exception with a general error message.
    if (!errorParamatersData || !errorParamatersData.errorType || !errorParamatersData.errorParamatersList || errorParamatersData.errorParamatersList.length <= 0) {
        // Throw an exception with all relevant parameter names.
        throw new Error(translate.error_missing.replace('#params#', getErrorParametersString(['errorParametersData', 'errorType', 'errorParametersList'])));
    }

    // Validate the error type. If no match is found - Throw a new exception with a general error message.
    if (Object.values(enums.MustAuthModalType).indexOf(errorParamatersData.errorType) < 0) {
        // Throw an exception with all relevant parameter names.
        throw new Error(translate.error_invalid.replace('#params#', 'errorType'));
    }

    // Throw an exception with all relevant parameter names.
    throw new Error(translate[`error_${errorParamatersData.errorType}`].replace('#params#', getErrorParametersString(errorParametersData.errorParametersList)));
}; */    

// Manually validate parameters just in case.
    validateParameters({
        props: props,
        parametersList: ['labelText', 'inputType', 'placeHolder']
    });

import { validateParameters } from '../../../utils/textUtils';



/* // Update the user emails total count on the state after successfully adding a new email to the user emails list.
export const onUserUpdateEmailsTotalCountSuccess = (state, action) => {
    console.log('update reducer', action);
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            userData: updateObject({
                oldObject: state.userData,
                updatedProperties: {
                    userEmailsTotalCount: action.userEmailsTotalCount
                }
            })
        }
    });
}; */   

 // Create the UserCredentials & UserData instances and save it on state and localStorage.
    const userInstances = yield call(toUserInstances, {
        userId: response.data.localId,
        userName: action.userAuthData.emailText,
        userPassword: action.userAuthData.passwordText,
        userToken: response.data.idToken,
        userTokenExpireInSeconds: response.data.expiresIn,
        userTokenExpirationDate: null,
        userEmailsTotalCount: userEmailsTotalCount
    });

    // Create a userLocalStorage instance template to save into the state and to localStorage.
    const userLocalStorageData = yield call(userUtils.getUserLocalStorageData, userInstances);

    // Set all the data to localStorage.
    yield call(userUtils.setUserAuth, userLocalStorageData);

    // Perform success action (remove any error and redirect the user to home page (search page)).
    yield put(actions.onUserAuthProcessSuccess(userLocalStorageData));

    // Check if the user token already expired (Need to be false, of course).
    yield put(actions.onUserAuthCheckTimeout(response.data.expiresIn));

userCredentials
userData

userCredentialsShape
userDataShape

/* // Update the user emails count on the state after successfully adding a new email to the user emails list.
export const onUserUpdateEmailsCountSuccess = (state, action) => {

    const updatedUser = { ...state.user };
    updatedUser.userEmailsCount = action.userEmailsCount;
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            user: updatedUser
        }
    });
}; */

/* // Update the user emails count on the state after successfully adding a new email to the user emails list.
export const onUserUpdateEmailsCountSuccess = (state, action) => {
    // Clone the state and update.
    return updateObject({
        oldObject: state,
        updatedProperties: {
            user: {
                ...state.user,
                userEmailsCount: 10
            }
        }
    });
};
 */

UserAuthParameter

isUserEmailsCountExceeded
isUserEmailsTotalCountExceeded
isUserEmailsTotalCountLimitExceeded
getUserEmailsCount

        this.userEmailsList
        this.userEmailsTotalCount
        this.userEmailsCountPerPage
        this.userEmailsPagesTotalCount
        this.userEmailsCurrentPageNumber
        this.userEmailsDeletedCount



emailsNavigation: {
            emailsCountPerPage: 10,
            currentPageNumber: 1,
            totalPagesCount: null
        },

getUserTokenLeftTime: ƒ ()
isUserAuthenticated: ƒ ()
isUserEmailsCountExeeded: ƒ ()
userEmailsCount: 10
userId: "NExFr0barvY8x4yC0jfZlipSyGV2"
userName: "test@test.com"
userToken: "eyJhbGciOiJSUzI1NiIsImtpZCI6ImEzMjJiNjhiY2U0MzExZTg2OTYzOTUzM2QzYTFhMjU1MWQ1ZTc0YzYifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vYnVyZ2VyLWJ1aWxkZXItODQ5MjEiLCJhdWQiOiJidXJnZXItYnVpbGRlci04NDkyMSIsImF1dGhfdGltZSI6MTUzODMxNTA1MywidXNlcl9pZCI6Ik5FeEZyMGJhcnZZOHg0eUMwamZabGlwU3lHVjIiLCJzdWIiOiJORXhGcjBiYXJ2WTh4NHlDMGpmWmxpcFN5R1YyIiwiaWF0IjoxNTM4MzE1MDUzLCJleHAiOjE1MzgzMTg2NTMsImVtYWlsIjoidGVzdEB0ZXN0LmNvbSIsImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwiZmlyZWJhc2UiOnsiaWRlbnRpdGllcyI6eyJlbWFpbCI6WyJ0ZXN0QHRlc3QuY29tIl19LCJzaWduX2luX3Byb3ZpZGVyIjoicGFzc3dvcmQifX0.dVM6eOOM73UiA-u5sN7i8pGkD9Mn2iF1u4GwyRRLPg7yoXxeUSQdMTvdf-P0lndZQwz0xJFN6dUHC5DIS42wgMOTEW1qQ5nL0pkdwcZej-_bhpuNWMwO-SrZGecuxJweni133y7gcz19f7xuNmpYGb6IcNvoXbrhFMgQTSyHKjItB19lZ5ojQv4gzvAyyIrJDo0R3sePzjUoEHWbLngQGq5Zo8mb2h_vM-pcd2NOSST1W6gidQK9HWj8fFbmmvK9em9419H3N53_jTSmKoObeEyzjEJqgqznSAxVy6E_8D7tPsa_epZU-aGazOw9hvnx7jBqjbX90MSoJRg7jLjLmQ"
userTokenExpirationDate: Sun Sep 30 2018 17:44:16 GMT+0300 (Israel Daylight Time) {}

// Generate the error message to display to the user after the API call returns an error.
export const getUserErrorMessage = (error) => {
    // Check if the parameter of the error exists. If not, return a general error.
    let errorMessage = translate.search_bar_error_general;
    if (!error || !error.response || !error.response.data || !error.response.data.error || !error.response.data.error.message) {
        return errorMessage;
    }

    // Check if the error is a common error to display a friendly message to the user.
    switch (error.response.data.error.message) {


        // No data supplied

        // Querying related parameters not supported on this request type


        /*         case errorAuthType.EMAIL_EXISTS:
                    errorMessage = translate.user_authentication_page_error_email_exists;
                    break;
                case errorAuthType.INVALID_EMAIL:
                    errorMessage = translate.user_authentication_page_error_email_invalid;
                    break;
                case errorAuthType.MISSING_PASSWORD:
                    errorMessage = translate.user_authentication_page_error_empty_password;
                    break;
                case errorAuthType.EMAIL_NOT_FOUND:
                    errorMessage = translate.user_authentication_page_error_auth_incorrect;
                    break; */
        default:
            break;
    }

    // Return the error message to the user.
    return errorMessage;
};

// Generate the error message to display to the user after the API call returns an error.
export const getUserAddEmailErrorMessage = (error) => {
    // Check if the parameter of the error exists. If not, return a general error.
    let errorMessage = translate.add_email_modal_error_general;
    if (!error || !error.response || !error.response.data || !error.response.data.error || !error.response.data.error.message) {
        return errorMessage;
    }

    // Check if the error is a common error to display a friendly message to the user.
    switch (error.response.data.error.message) {


        // No data supplied

        // Querying related parameters not supported on this request type


        /*         case errorAuthType.EMAIL_EXISTS:
                    errorMessage = translate.user_authentication_page_error_email_exists;
                    break;
                case errorAuthType.INVALID_EMAIL:
                    errorMessage = translate.user_authentication_page_error_email_invalid;
                    break;
                case errorAuthType.MISSING_PASSWORD:
                    errorMessage = translate.user_authentication_page_error_empty_password;
                    break;
                case errorAuthType.EMAIL_NOT_FOUND:
                    errorMessage = translate.user_authentication_page_error_auth_incorrect;
                    break; */
        default:
            break;
    }

    // Return the error message to the user.
    return errorMessage;
};

export const SearchOptionProperty = createEnum(new Map([
    ['VALUE', 'value'],
    ['IS_SEARCH_OPTION_SHOW', 'isSearchOptionShow'],
    ['MODE', 'mode'],
    ['ERROR_MESSAGE', 'errorMessage'],
    ['TOGGLE', 'toggle']
]));      

  // Create data to update.
        const updatedDeleteEmail = updateObject({
            oldObject: this.state.deleteEmail,
            updatedProperties: {
                emailId: data.emailId,
                email: data.email
            }
        });

Set the setSearchOptionStatus function by new properties:
searchOptionType
searchOptionsList
errorMessage


// Set the specific search options from the list, by searchOptionType key.
const setSearchOptionStatus = (searchOptionsList, currentSearchOptionType, errorMessage) => {
    // Search the search option type. If not found - Don't do nothing.
    const searchErrorStatusIndex = searchOptionsList.findIndex(srcOpt => srcOpt.searchOptionType === currentSearchOptionType);
    if (searchErrorStatusIndex < 0) {
        return;
    }

    // Re-assign the relevant values and update the array.
    searchOptionsList[searchErrorStatusIndex] = {
        searchOptionType: currentSearchOptionType,
        isValid: errorMessage === null,
        errorMessage: errorMessage
    };
    return searchOptionsList;
};    

// Get the class of the button within the desired color.
    const differentClass = generateClassName({
        condition: props.isDifferentColor,
        originalClassName: 'btn btn-default',
        newClassName: 'different'
    });

// Merges 2 classes together if the given condition is true.
export const generateClassName = (condition, originalClassName, newClassName) => {
    // Check that parameters exist.
    if (!originalClassName && !newClassName) {
        return null;
    }

    // Will hold the result.
    let resultClass = originalClassName;
    if (condition) {
        // Add the new class to the old one.
        resultClass += ` ${newClassName}`;
    }

    // Return calculated result.
    return resultClass;
};

// Generate text by random counts.
const generateRandomText = (randomTextData) => {
    // Check for existence of the parameters.
    if (!randomTextData || !randomTextData.minimumStringsCount || !randomTextData.maximumStringsCount ||
        isNaN(randomTextData.minimumStringsCount) || isNaN(!randomTextData.maximumStringsCount)) {
        return;
    }

    // Get random characters length
    const stringsCount = generateRandomNumber(randomTextData.minimumStringsCount, randomTextData.maximumStringsCount);
    // Wil hold the final search key result.
    let searchKey = '';
    // Append the search key by loop count of random strings.
    for (let i = 0; i < stringsCount; i++) {
        searchKey += `${generateRandomString(settings.minimumStringLength, settings.maximumStringLength)} `;
    }
    // Slice the last space and return calculated append string
    return searchKey.slice(0, -1);
};

// Generate a random search engine.
const generateRandomSearchEngine = () => {
    // Return random search engine.
    return settings.searchEngineArray[generateRandomNumber(0, settings.searchEngineArray.length - 1)];
};

// Generate a random link.
const generateRandomLink = () => {
    const linkData = {
        linkKey: generateRandomString(generateRandomNumber(settings.minimumLinkLength, settings.maximumLinkLength)),
        linkEnd: settings.linkEndsArray[generateRandomNumber(0, settings.linkEndsArray.length - 1)]
    };

    // Return random URL address.
    return `http${ generateRandomBoolean() ? 's' : '' }://www.${linkData.linkKey}.${linkData.linkEnd}`;
};

// Generate random email.
const generateRandomEmail = () => {
    // Create template base results.
    const emailData = {
        emailKey: generateRandomString(generateRandomNumber(settings.minimumEmailLength, settings.maximumEmailLength)),
        emailDomain: settings.domainsArray[generateRandomNumber(0, settings.domainsArray.length - 1)]
    };
    return `${emailData.emailKey}@${emailData.emailDomain}`;
};

// Generate random number. 
const generateRandomNumber = (minimum, maximum) => {
    return Math.floor(Math.random() * maximum) + minimum;
};

// Generate text by random counts.
const generateRandomText = (minimumStringsCount, maximumStringsCount) => {
    const stringsCount = generateRandomNumber(minimumStringsCount, maximumStringsCount);
    let searchKey = '';
    for (let i = 0; i < stringsCount; i++) {
        searchKey += `${generateRandomString(settings.minimumStringLength, settings.maximumStringLength)} `;
    }
    return searchKey.slice(0, -1);
};

// Validate that given value is an array with a specific length. This function was created 
// since to the current production development, so Proptypes don't have validation on array's length.
export const validateArray = (arrayData) => {
    console.log(arrayData);
    // Check for existence and validity of the parameters.
    if (!arrayData || !arrayData.array || !arrayData.arrayLength || isNaN(arrayData.arrayLength)) {
        return false;
    }

    // Check for type of array with specific count.
    if (!Array.isArray(arrayData.array) || arrayData.array.length !== arrayData.arrayLength) {
        return false;
    }

    // Return calculated result.
    return true;
};
 

   "search_example_search_key_text": "This is example of search key",
    "search_example_comments_text": "This is example of comments",

This is example of search key
This is example of comments

// This function will validate all the search options when the search
// process begins or when the search options panel closes.
const validateSearchOptions = (searchData, validationResult) => {
    // Will determine if any of the search options are valid or not.
    let isValidSearch = true;

    // Validate search options (if entered).
    for(let i; i < searchData.searchOptions.length; i++)
    {
        
    }
searchData.searchOptions.forEach(src => {
        // Check if data is entered to perform validation,
        // And check the search option type and if needed, Skip validation on Url domains if the search mode is url.
        // (Search emails on specific url, no need to include/exclude url domains) and continue to the next search option.
        if (!src.value || (searchData.searchMode === enums.SearchMode.URL && src.searchOptionType === enums.SearchElementType.URLS)) {
            validationResult.searchOptionsList = setSearchOptionStatus(validationResult.searchOptionsList, src.searchOptionType, null);
            return;
        }

        // Get the data by the current search option. If not found -
        // Something went wrong and the search is invalid, return a general error to display the user.
        const searchModeData = dataArray.get(src.searchOptionType);
        if (!searchModeData) {
            validationResult.errorToConsole = {
                errorType: enums.ErrorType.MISSING,
                parameters: ['searchModeData']
            };
            isValidSearch = false;
            return;
        }

        // Check that the value is not exceeded maximum length.
        if (!validationUtils.validateCharactersLength({
                value: src.value,
                validationType: enums.ValidateCharactersType.MAX,
                charactersCount: searchModeData.maximumCharactersCount
            })) {
            validationResult.searchOptionsList = setSearchOptionStatus(validationResult.searchOptionsList, src.searchOptionType,
                searchModeData.maximumCharactersErrorText.replace('#count#', searchModeData.maximumCharactersCount));
            isValidSearch = false;
            return;
        }

        // Validate the data according to the current search option.
        const searchOptionValidationResult = searchModeData.validationFunction(src.value);
        if (!searchOptionValidationResult) {
            validationResult.errorToConsole = {
                errorType: enums.ErrorType.MISSING,
                parameters: ['searchOptionValidationResult']
            };
            isValidSearch = false;
            return;
        }

        // If invalid print an error message with the specific invalid value.
        if (!searchOptionValidationResult.isValid) {
            validationResult.searchOptionsList = setSearchOptionStatus(validationResult.searchOptionsList, src.searchOptionType,
                searchModeData.errorValidationText.replace('#invalid#', searchOptionValidationResult.invalidValue));
            isValidSearch = false;
            return;
        }

        // If error exists - Break the loop. If not exists - Set the field to be valid.
        if (isValidSearch) {
            validationResult.searchOptionsList = setSearchOptionStatus(validationResult.searchOptionsList, src.searchOptionType, null);
        } else {
            return validationResult;
        }
    });
    return validationResult;
};   

 // Check for existence and validity of the parameters.
    if (!validateLengthData || !validateLengthData.value || !validateLengthData.validationType ||
        !validateLengthData.charactersCount || isNaN(validateLengthData.charactersCount)) {
        return false;
    }

// Validate a given value of maximum/minimum length.
export const validateCharactersLength = (value, validationType, charactersCount) => {
    // Check for existence of the parameter.
    if (!value || !validationType || !charactersCount) {
        return false;
    }

    // Check if to validate by maximum/minimum length and return calculated result..
    switch (validationType) {
        case enums.ValidateCharactersType.MAX:
            return value.length < charactersCount;
        case enums.ValidateCharactersType.MIN:
            return value.length > charactersCount;
        default:
            return false;
    }
};

/* // Create the map data transactions by userAuthMode type.
const transactions = new Map([
    [enums.UserAuthModeType.LOGIN,
        {
            pageTitle: translate.user_authentication_page_login_title,
            formTitle: translate.user_authentication_form_login_title,
            buttonText: translate.user_authentication_page_login_button,
            bottomText: translate.user_authentication_page_login_switch_link,
            linkText: translate.user_authentication_page_login_link_text
        }
    ],
    [enums.UserAuthModeType.REGISTRATION,
        {
            pageTitle: translate.user_authentication_page_registration_title,
            formTitle: translate.user_authentication_form_registration_title,
            buttonText: translate.user_authentication_page_registration_button,
            bottomText: translate.user_authentication_page_registration_switch_link,
            linkText: translate.user_authentication_page_registration_link_text
        }
    ]
]); */
{translate[`user_authentication_page_${props.userAuthMode}_link_text`]}
                                        {translate[`user_authentication_page_${props.userAuthMode}_switch_link`]}

Old:
    isHomePage: PropTypes.bool.isRequired,
    id: PropTypes.string.isRequired,

/* // On Firebase the results warraped with the id token, and there is a need to extract it.
// In node.js API server we would need this method to parse some elements (Search engine enum, creation date, so on..).
// Also, we limit the search results emails count to 10 as maximum.
export const parseSearchResults = (emails) => {
    // Will hold the return new array of emails.
    const fetchedEmails = [];
    // If invalid parameter or empty array, return an empty array.
    if (!emails || Object.keys(emails).length === 0) {
        return fetchedEmails;
    }

    // Take only the first 10 emails to display, since we don't want to display more than that (short and fast searches).
    if (Object.keys(emails).length > 10) {
        emails = Object.entries(emails).slice(0, 10).map(entry => entry[1]);
    }

    // Loop on the key/value result from the server and fetch them into an email array.
    for (let key in emails) {
        // Convert the creation date to date object.
        fetchedEmails.push({
            ...emails[key],
            creationDate: new Date(Date.parse(emails[key].creationDate))
        });
    }
    return fetchedEmails;
}; */   

 email: PropTypes.string.isRequired,
    link: PropTypes.string.isRequired,
    creationDate: PropTypes.PropTypes.instanceOf(Date).isRequired,
    searchEngine: PropTypes.string.isRequired,
    searchKey: PropTypes.string.isRequired,
    comments: PropTypes.string,
    emailActionType: PropTypes.string,
    isMoreInfoMode: PropTypes.bool.isRequired,
    onActionIconClick: PropTypes.func.isRequired,
    onMoreInfoToggleClick: PropTypes.func

/* a. When API returns results - send to one method that does validation and after that - convert all the response.data to classes.
b. When moving to class email - in the parse function also include the email string to date time.
c. Search about Proptypes of class.
d. Add field of EmailType - also to enum - "FAKE" / "SEARCH".
 */
/*         // The Id of the user as generated on the database.
        this.userId = userData.userId;
        // The username of the user (email of the user) that will display
        // on the site, and with it the user can login to the system.
        this.userName = userData.userName;
        // Determine if the user is authenticated or not.
        this.userToken = userData.userToken;
        // Determine if the user is authenticated or not, if the user token is expired or not. 
        // Since the result of the user token expiration date should be date object and not string (like saved on localStorage),
        // We convert it to date and re-assign it.
        this.userTokenExpirationDate = null;
        // The logic of the user token expiration date faces 2 scenarios:
        // 1. When the user logged in / registered - the userData.userTokenExpireIn - It's a number of seconds that the token will expire (usually it's 3600 - 1 Hour).
        // In this case we need to convert it to date time and store it.
        // 2. When the user refreshes the browser and gets the expiration date from the localStorage as a string. In this case we only need to convert it to a new Date.
        // Note that there is no case where both userTokenExpireInSeconds and userTokenExpirationDate will be valued. One of them will always be null to not override the field.
        if (userData.userTokenExpireInSeconds) {
            // Assign the user token expiration date.
            // Will hold the expiration time of the token by seconds (Multiply 1000 in the milliseconds number).
            this.userTokenExpirationDate = new Date(new Date().getTime() + userData.userTokenExpireInSeconds * settings.api_user_auth_token_milliseconds_count);
        }

        if (userData.userTokenExpirationDate) {
            // Assign the user token expiration date (that received from localStorage) as string, by converting it to a new Date.
            this.userTokenExpirationDate = new Date(userData.userTokenExpirationDate);
        }
        // This field determines the number of the emails list. We need to keep it to verify
        // that the user is not over the limit of emails to save in this emails list.
        // Since in localStorage the emails count as strings too, it needs to convert to a number and return it.
        // If not exists - Assign default value of 0.
        this.userEmailsCount = Number(userData.userEmailsCount);
        // Check if the number from state/localStorage is valid.
        if (isNaN(this.userEmailsCount)) {
            this.userEmailsCount = 0;
        } */

emailId: PropTypes.string.isRequired,
    emailUserId: PropTypes.string,
    emailUserAddedDate: PropTypes.instanceOf(Date),
    emailAddress: PropTypes.string.isRequired,
    emailLink: PropTypes.string.isRequired,
    emailCreationDate: PropTypes.instanceOf(Date).isRequired,
    emailSearchEngine: PropTypes.string.isRequired,
    emailSearchKey: PropTypes.string.isRequired,
    emailComments: PropTypes.string,
    emailActionType: PropTypes.string.isRequired,
    isEmailMoreInfoMode: PropTypes.bool.isRequired    

import { isUserAuthenticated } from '../../utils/userUtils';
isUserAuthenticated(props.user)    





// Fetch fake emails.
    let emails = yield call(generateFakeEmails, action.searchData.emailsCount);
    // Convert the emails data to email classes instances.
    emails = yield call(toEmails, {
        emailsCount: 0,
        emailsArray: emails,
        isDefaultProcess: true
    });

/* // This function will convert fake emails that are created from generated inner code into Email class instances.
const toFakeEmails = (emailsArrayData) => {
    if (!dataArray || dataArray.length === 0) {
        return [];
    }

    // Will hold the array of emails.
    const emailsArray = [];
    for (let i = 0; i < dataArray.length; i++) {
        emailsArray.push(toEmail(dataArray[i]));
    }
    return emailsArray;
}; */


// This function gets an array of strings data (from API server request 
// or fake emails array) and converts them into email classes instances.
// On Firebase the results are wrapped with the id token, and there is a need to extract it.
// The Email class would need this method to parse some elements (Search engine enum, creation date, so on..).
// The part of extracting from the server will not be needed when the site will work with Node.js API.

// limitCount = number
// extractFromServer = bool,
// dataArray = array.
export const toEmails = (emailsArrayData) => {
    // Will hold the return new array of emails.
    const emailsArray = [];
    // Check the existence and validity of the array. invalid parameter or empty array, return empty array.
    if (!emailsArrayData || !emailsArrayData.dataArray || Object.keys(emailsArrayData.dataArray).length === 0) {
        return [];
    }

    // Take only the first 10 emails to display, since we don't want to display more than that (short and fast searches).
    if (Object.keys(dataArray).length > 10) {
        dataArray = Object.entries(dataArray).slice(0, 10).map(entry => entry[1]);
    }

    // Loop on the key/value result from the server and fetch them into an email array.
    // If its from server - Extract from top object with server id by the server top id key.

    for (let key in dataArray) {
        // Convert the creation date to date object.
        emailsArray.push(toEmail(dataArray[key]));
    }

    for (let i = 0; i < dataArray.length; i++) {
        emailsArray.push(toEmail(dataArray[i]));
    }
    return emailsArray;
};

/* // On Firebase the results warraped with the id token, and there is a need to extract it.
// In node.js API server we would need this method to parse some elements (Search engine enum, creation date, so on..).
// Also, we limit the search results emails count to 10 as maximum.
export const parseSearchResults = (emails) => {
    // Will hold the return new array of emails.
    const fetchedEmails = [];
    // If invalid parameter or empty array, return an empty array.
    if (!emails || Object.keys(emails).length === 0) {
        return fetchedEmails;
    }

    // Take only the first 10 emails to display, since we don't want to display more than that (short and fast searches).
    if (Object.keys(emails).length > 10) {
        emails = Object.entries(emails).slice(0, 10).map(entry => entry[1]);
    }

    // Loop on the key/value result from the server and fetch them into an email array.
    for (let key in emails) {
        // Convert the creation date to date object.
        fetchedEmails.push({
            ...emails[key],
            creationDate: new Date(Date.parse(emails[key].creationDate))
        });
    }
    return fetchedEmails;
};

// Will hold the array of emails.
const emailsArray = [];
for (let i = 0; i < dataArray.length; i++) {
    emailsArray.push(toEmail(dataArray[i]));
}
return emailsArray;
}; */

/* // On Firebase the results warraped with the id token, and there is a need to extract it.
// In node.js API server we would need this method to parse some elements (Search engine enum, creation date, so on..).
// Also, we limit the search results emails count to 10 as maximum.
export const parseSearchResults = (emails) => {
    // Will hold the return new array of emails.
    const fetchedEmails = [];
    // If invalid parameter or empty array, return an empty array.
    if (!emails || Object.keys(emails).length === 0) {
        return fetchedEmails;
    }

    // Take only the first 10 emails to display, since we don't want to display more than that (short and fast searches).
    if (Object.keys(emails).length > 10) {
        emails = Object.entries(emails).slice(0, 10).map(entry => entry[1]);
    }

    // Loop on the key/value result from the server and fetch them into an email array.
    for (let key in emails) {
        // Convert the creation date to date object.
        fetchedEmails.push({
            ...emails[key],
            creationDate: new Date(Date.parse(emails[key].creationDate))
        });
    }
    return fetchedEmails;
}; */

import * as enums from '../../enums/enums';
import { getDateConverted } from '../../utils/textUtils';

class Email {
    constructor(emailData) {
        // Check if data received exists. If not - Don't assign any value to the user instance.
        if (!emailData) {
            return;
        }
        // The Id of the user as generated by database or by the code (Depending if it's fake email or not).
        this.emailId = emailData.emailId;
        // Check if the emailUserId exists, to assign it. Only when the
        // user adds the email to his emails list, the emailUserId is added.
        // This is the user Id of the user that saved the emails into his emails list. 
        // In fake emails we don't have this field. Once a user decides to save
        // an email into his emails list, this field is added dynamically.
        this.emailUserId = emailData.emailUserId;
        // Check if the emailUserAddedDate exists, to assign it. Only when the
        // user adds the email to his emails list, the emailUserAddedDate is added.
        // This is the date of when the user saved the email into his emails list. 
        // In fake emails we don't have this field. Once user decide to save
        // an email into his emails list, this field added dynamically.
        this.emailUserAddedDate = getDateConverted(emailData.emailCreationDate);
        // The email address is generated by the API server search process or
        // by random string and domain ending (Depending if it's fake email or not).
        this.emailAddress = emailData.emailAddress;
        // This is the url that the email was found inside it's view source code. 
        // In fake emails type it also a random string with random domain name.
        this.emailLink = emailData.emailLink;
        // The creation date of the email. The API server search process is the date of 
        // the email that was found. In fake emails, it's just a random date.
        // Note that we check that if the given value is a string, we try to convert it.
        this.emailCreationDate = getDateConverted(emailData.emailCreationDate);
        // The search engine website that the email was found in. In fake emails it's a random within 'SearchEngine' enum.
        this.emailSearchEngine = emailData.emailSearchEngine;
        // The search key that within the search process found the email. In fake emails it's a random string.
        this.emailSearchKey = emailData.emailSearchKey;
        // Check if there are comments.
        // The comments added when the user decided to add the email to his emails
        // list, although the comments are not required for adding the email to the emails list,
        this.emailComments = emailData.emailComments;
        // This field determines the type of the email, whether it's created by the result of the search process
        // or by a result of generating by a random fake operation just to show data on the home page.
        this.emailType = emailData.emailType;
        // This is a field that is generated for UI purposes and therefore not included 
        // in the database. For each action from 'EmailActionType' enum.
        // The default value is 'CREATED' which does not affect the UI in any case. 
        this.emailActionType = enums.EmailActionType.CREATED;
        // This field also responsible for showing or hiding the full details panel on the
        // "my-emails" page, so this field is also not included in the database.
        // The default value is false.
        this.isEmailMoreInfoMode = false;
    }
}

// Validate that value is a valid date.
export const validateDate = (date) => {
    // Check for existence of the parameter.
    if (!date) {
        return false;
    }
    // Return calculated result.
    return date instanceof Date && !isNaN(date);
};

// Validate that the value's type is a string.
export const validateString = (value) => {
    // Check for existence of the parameter.
    if (!value) {
        return false;
    }
    // Return calculated result.
    return typeof value.emailCreationDate === 'string' || value.emailCreationDate instanceof String;
};

isUserAuthenticated
isUserEmailsCountExeeded
getUserTokenLeftTime
      
  userId: getItem(enums.UserAuthParameter.USER_ID),
        userName: getItem(enums.UserAuthParameter.USER_NAME),
        userToken: getItem(enums.UserAuthParameter.USER_TOKEN),
        userTokenExpirationDate: getItem(enums.UserAuthParameter.USER_TOKEN_EXPIRATION_DATE),
        userEmailsCount: getItem(enums.UserAuthParameter.USER_EMAILS_COUNT)

mokedbi@migdal.co.il

PropTypes.bool.

// This function generates a timeout delay in milliseconds for the user token expiration.
// After this time the user will logout from the system.
export const getTimeOutDelay = (expirationTime) => {
    // Validate the expirationTime parameter.
    if (!expirationTime) {
        return 0;
    }

    // Convert to a number.
    expirationTime = Number(expirationTime);

    // Make sure the conversion is valid.
    if (isNaN(expirationTime)) {
        return 0;
    }

    // Return the calculated result.
    return expirationTime * settings.api_user_auth_token_milliseconds_count;
};

// This function generates a valid user token expiration date.
export const getUserTokenExpirationTime = (expirationIn) => {
    // Validate the expirationIn parameter.
    if (!expirationIn) {
        return 0;
    }
    return new Date(new Date().getTime() + expirationIn * settings.api_user_auth_token_milliseconds_count);
};

// This function calculates the time left for the user token to expire to renew the delay until logout.
export const getUserTokenLeftTime = (userTokenExpirationDate) => {
    // Validate the expirationDate parameter.
    if (!userTokenExpirationDate) {
        return 0;
    }
    return (userTokenExpirationDate.getTime() - new Date().getTime()) / settings.api_user_auth_token_milliseconds_count;
};


                                            <ErrorBox text={props.generalError}
                                                noArrow={true}
                                                searchOption={false}
                                                searchOptionGeneral={false} />

showModal
isShowModal

showSearchOptions
isShowSearchOptions

emailsError
isEmailsError

moreInfoMode   
isMoreInfoMode


 const validationResult = {
        isValid: false,
        textBoxType: null,
        errorMessage: null
    };

        validationResult.textBoxType = enums.UserAuthInputType.PASSWORD;
        validationResult.errorMessage = translate.user_authentication_page_error_empty_password;


// This function validates the must auth modal type on MustAuth component.
export const validateMustAuthModalType = (mustAuthModalType) => {
    if (!mustAuthModalType) {
        return false;
    }

    switch (mustAuthModalType) {
        case enums.MustAuthModalType.ADD:
        case enums.MustAuthModalType.SEARCH:
            return true;
        default:
            return false;
    }
};    


// Validate that the search option is valid.
    // Check the validity of the search mode parameter. If invalid - Show a message to the user and console error.
    if (Object.values(enums.SearchMode).indexOf(action.searchModeData.newSearchMode) < 0) {
        yield call(searchOptionErrorSaga, {
            errorType: enums.ErrorType.INVALID,
            errorParameters: ['newSearchMode']
        });
        return;
    }

export const SearchEngine = createEnum(new Map([
    ['BING', 'Bing'],
    ['YAHOO', 'Yahoo!'],
    ['ASK_COM', 'Ask.com'],
    ['AOL', 'AOL'],
    ['BAIDU', 'Baidu'],
    ['DUCK_DUCK_GO', 'DuckDuckGo']
]));


translate.add_email_modal_error_general

validateLoginUserAuthMode
validateRegistrationUserAuthMode

changed:
onUserAuthInputChangeStart *
onUserAuthInputChangeSuccess *
onUserAuthProcessStart *
onUserAuthProcessValidationError *
onUserAuthProcessSuccess *

-----------------------

import * as actionTypes from '../actionTypes';

// This action is called when any page first loads to reset all the user auth state inputs and settings.
export const onUserAuthResetStateSuccess = () => {
    return {
        type: actionTypes.USER_AUTH_RESET_STATE_SUCCESS
    };
};

// This action is called when any input changes (email or password) on the user auth page.
export const onUserAuthInputChangeStart = (userAuthInputChangeData) => {
    return {
        type: actionTypes.USER_AUTH_INPUT_CHANGE_START,
        textBoxType: userAuthInputChangeData.textBoxType,
        textBoxValue: userAuthInputChangeData.textBoxValue
    };
};

// This action is called when any input changes successfully (email or password) on the user auth page.
export const onUserAuthInputChangeSuccess = (userAuthInputChangeData) => {
    return {
        type: actionTypes.USER_AUTH_INPUT_CHANGE_SUCCESS,
        textBoxType: userAuthInputChangeData.textBoxType,
        textBoxValue: userAuthInputChangeData.textBoxValue
    };
};

// This action is called when the user auth mode link clicked (Login or Registration) on the user auth page.
export const onUserAuthModeChangeStart = (userAuthMode) => {
    return {
        type: actionTypes.USER_AUTH_MODE_CHANGE_START,
        userAuthMode: userAuthMode
    };
};

// This action called when user auth mode changed successfully (Login or Registration) on the user auth page.
export const onUserAuthModeChangeSuccess = (userAuthMode) => {
    return {
        type: actionTypes.USER_AUTH_MODE_CHANGE_SUCCESS,
        userAuthMode: userAuthMode
    };
};

// This action is called when the user clicks on the Login/Registration button on the user auth form.
export const onUserAuthProcessStart = (userAuthData) => {
    return {
        type: actionTypes.USER_AUTH_PROCESS_START,
        userAuthMode: userAuthData.userAuthMode,
        emailText: userAuthData.emailText,
        passwordText: userAuthData.passwordText
    };
};

// After validation was successfully passed on the user auth process, this action call.
export const onUserAuthProcessPreparation = () => {
    return {
        type: actionTypes.USER_AUTH_PROCESS_PREPARATION
    };
};

// If the validation failed in any of the inputs on the user auth process, this action is called.
export const onUserAuthProcessValidationError = (userAuthValidationErrorData) => {
    return {
        type: actionTypes.USER_AUTH_PROCESS_VALIDATION_ERROR,
        textBoxType: userAuthValidationErrorData.textBoxType,
        errorMessage: userAuthValidationErrorData.errorMessage
    };
};

// This action called after the user auth process (login or registration) was completed successfully.
export const onUserAuthProcessSuccess = (userAuthData) => {
    return {
        type: actionTypes.USER_AUTH_PROCESS_SUCCESS,
        userToken: userAuthData.userToken,
        userId: userAuthData.userId,
        userName: userAuthData.userName,
        userTokenExpirationDate: userAuthData.userTokenExpirationDate,
        userEmailsCount: userAuthData.userEmailsCount
    };
};

// When a user tries to login and enter the wrong email or password, this action is called.
export const onUserAuthProcessFail = (errorMessage) => {
    return {
        type: actionTypes.USER_AUTH_PROCESS_FAIL,
        error: errorMessage
    };
};

// This action is called each time there is a need to check the validity of the user auth token expiration time.
export const onUserAuthCheckTimeout = (expirationTime) => {
    return {
        type: actionTypes.USER_AUTH_CHECK_TIMEOUT,
        expirationTime: expirationTime
    };
};

// This action is called when the application raises to check if the user is authenticated or not.
export const onUserAuthCheckState = () => {
    return {
        type: actionTypes.USER_AUTH_CHECK_STATE
    };
};

// This action is called when the user clicks on the "Logout" tab and wants to logout from the application.
export const onUserAuthLogoutStart = () => {
    return {
        type: actionTypes.USER_AUTH_LOGOUT_START
    };
};

// This action is called when the logout process completes successfully.
export const onUserAuthLogoutSuccess = () => {
    return {
        type: actionTypes.USER_AUTH_LOGOUT_SUCCESS
    };
};

// This action is called when all the validations have passed and the process of 
// adding the email to the user's emails list is ready to go on the search page.
export const onUserAddEmailProcessStart = (userAddEmailData) => {
    return {
        type: actionTypes.USER_ADD_EMAIL_PROCESS_START,
        userAddEmailData: userAddEmailData
    };
};

// This action is called after the new email is added successfully to the user 
// emails's list and there is a need to update the user emails count on the state.
export const onUserUpdateEmailsCountSuccess = (userEmailsCount) => {
    return {
        type: actionTypes.USER_UPDATE_EMAILS_COUNT_SUCCESS,
        userEmailsCount: userEmailsCount
    };
};

export const USER_AUTH_RESET_STATE_SUCCESS = 'USER_AUTH_RESET_STATE_SUCCESS';

export const SEARCH_RESET_STATE_SUCCESS = 'SEARCH_RESET_STATE_SUCCESS';

export const SEARCH_MODAL_TOGGLE_START = 'SEARCH_MODAL_TOGGLE_START';
export const SEARCH_MODAL_TOGGLE_SUCCESS = 'SEARCH_MODAL_TOGGLE_SUCCESS';   

 "user_authentication_modal_add_emails_text": "In order to add emails you must register or login to the system",
    "user_authentication_modal_search_emails_text": "In order to search emails you must register or login to the system",

search_advance_options_general_error

AdvancedSearchOption
AdvancedSearchOptionType


export const userAuthModeType = {
    LOGIN: 'login',
    REGISTRATION: 'registration'
};

export const userAuthInputType = {
    email: 'email',
    password: 'password'
};

export const userAuthAPIMethod = {
    signupNewUser: 'signupNewUser',
    verifyPassword: 'verifyPassword'
};

export const userAuthParameter = {
    UserToken: 'userToken',
    UserID: 'userId',
    UserName: 'userName',
    UserTokenExpirationDate: 'userTokenExpirationDate',
    UserEmailsCount: 'userEmailsCount'
};

export const searchMode = {
    TEXT: 'text',
    URL: 'url'
};

export const searchOption = {
    INCLUDE: 'include',
    EXCLUDE: 'exclude'
};

export const searchOptionType = {
    SEARCHKEY: 'search-key',
    MODE: 'search-mode',
    DOMAINS: 'email-domains',
    KEYS: 'email-keys',
    URLS: 'urls'
};

export const emailActionType = {
    CREATED: 'created',
    ADDED: 'added',
    DELETED: 'deleted'
};

export const modalName = {
    AddEmail: 'add-email',
    DeleteEmail: 'delete-email',
    EmailsLimit: 'emails-limit',
    MustAuth: 'must-auth'
};

export const pagerLink = {
    NEXT: 'next',
    PREVIOUS: 'previous'
};

export const validateCharactersType = {
    MIN: 'minimum',
    MAX: 'maximum'
};

export const errorType = {
    MISSING: 'missing',
    INVALID: 'invalid'
};

export const errorAuthType = {
    EMAIL_EXISTS: 'EMAIL_EXISTS',
    INVALID_EMAIL: 'INVALID_EMAIL',
    MISSING_PASSWORD: 'MISSING_PASSWORD',
    EMAIL_NOT_FOUND: 'EMAIL_NOT_FOUND',
    TOKEN_EXPIRED: 'TOKEN_EXPIRED'
};

export const apiRouteType = {
    AUTH: 'auth',
    FAKE_EMAILS: 'fake_emails',
    USER_EMAILS: 'user_emails'
};


-----------------------------------------------------

export const UserAuthModeType = createEnum(new Map([
    ['LOGIN', 'login'],
    ['REGISTRATION', 'registration']
]));

export const UserAuthAPIMethod = createEnum(new Map([
    ['SIGNUP_NEW_USER', 'signupNewUser'],
    ['VERIFY_PASSWORD', 'verifyPassword']
]));

export const UserAuthParameter = createEnum(new Map([
    ['USER_TOKEN', 'userToken'],
    ['USER_ID', 'userId'],
    ['USER_NAME', 'userName'],
    ['USER_TOKEN_EXPIRATION_DATE', 'userTokenExpirationDate'],
    ['USER_EMAILS_COUNT', 'userEmailsCount']
]));

export const errorAuthType = createEnum(new Map([
    ['EMAIL_EXISTS', 'EMAIL_EXISTS'],
    ['INVALID_EMAIL', 'INVALID_EMAIL'],
    ['MISSING_PASSWORD', 'MISSING_PASSWORD'],
    ['EMAIL_NOT_FOUND', 'EMAIL_NOT_FOUND'],
    ['TOKEN_EXPIRED', 'TOKEN_EXPIRED']
]));

export const PagerLink = createEnum(new Map([
    ['NEXT', 'next'],
    ['PREVIOUS', 'previous']
]));

export const SearchMode = createEnum(new Map([
    ['TEXT', 'text'],
    ['URL', 'url']
]));

export const AdvancedSearchOption = createEnum(new Map([
    ['INCLUDE', 'include'],
    ['EXCLUDE', 'exclude']
]));

export const AdvancedSearchOptionType = createEnum(new Map([
    ['SEARCHKEY', 'search-key'],
    ['MODE', 'search-mode'],
    ['DOMAINS', 'email-domains'],
    ['KEYS', 'email-keys'],
    ['URLS', 'urls']
]));

export const EmailActionType = createEnum(new Map([
    ['CREATED', 'created'],
    ['ADDED', 'added'],
    ['DELETED', 'deleted']
]));

export const UserAuthInputType = createEnum(new Map([
    ['EMAIL', 'email'],
    ['PASSWORD', 'password']
]));

export const ModalName = createEnum(new Map([
    ['ADD_EMAIL', 'add-email'],
    ['DELETE_EMAIL', 'delete-email'],
    ['EMAILS_LIMIT_EXCEEDED', 'emails-limit-exceeded'],
    ['MUST_AUTH', 'must-auth']
]));

export const ValidateCharactersType = createEnum(new Map([
    ['MIN', 'minimum'],
    ['MAX', 'maximum']
]));

export const ErrorType = createEnum(new Map([
    ['MISSING', 'missing'],
    ['INVALID', 'invalid']
]));

export const apiRouteType = createEnum(new Map([
    ['AUTH', 'auth'],
    ['FAKE_EMAILS', 'fake_emails'],
    ['USER_EMAILS', 'user_emails']
]));

import * as enums from '../../../enums/enums';

createEnum

var fields = ['name','age','address'];
var info = {
  name: "John Doe",
  age: "",
  phone: "123-456-7890"
}


var validateFields = function(o, required_fields) {
  required_fields.forEach(function(field){
    if(o.hasOwnProperty(field)){
      if(o[field]){
        console.log(field + ": " + o[field]);
      }else{
        console.log(field + " exists but is empty");
      }
    }else{
      console.log(field + " doesn't exist in object");
    }
  });
}

validateFields(info, fields);



userEmailsCount

export const USER_UPDATE_EMAILS_COUNT_SUCCESS = 'USER_UPDATE_EMAILS_COUNT_SUCCESS';

--------------------------------------

export const USER_ADD_EMAIL_PROCESS_START = 'USER_ADD_EMAIL_PROCESS_START';
export const USER_ADD_EMAIL_PROCESS_SUCCESS = 'USER_ADD_EMAIL_PROCESS_SUCCESS';


// This method checks if the user has passed the limit to save emails to his emails list.
export const checkUserEmailsLimitExceeded = (userAuthData) => {
    // Will hold the final result.
    let isUserEmailsCountExeeded = false;

Old:

export const userAuthParameter = {
    Token: 'token',
    UserID: 'userId',
    UserName: 'userName',
    ExpirationDate: 'expirationDate',
    EmailsCount: 'emailsCount'
};

new:

export const userAuthParameter = {
    UserToken: 'userToken',
    UserID: 'userId',
    UserName: 'userName',
    UserTokenExpirationDate: 'userTokenExpirationDate',
    UserEmailsCount: 'userEmailsCount'
};



old: authModeType
new: userActionModeType

shallow=true

onSearchAddEmailModalToggleSuccess
onSearchAddEmailProcessFail      
isAuthenticated: checkAuthentication({
            token: state.auth.token,
            expirationDate: state.auth.expirationDate
        }).isAuthenticated,
        isComponentMounted: state.search.isComponentMounted,
        isLoadingEmails: state.search.isLoadingEmails,
        searchKeyTempValue: state.search.searchKeyTempValue,
        searchKeyInputValue: state.search.searchKeyInputValue,
        searchKeyErrorMessage: state.search.searchKeyErrorMessage,
        searchErrorRefType: state.search.searchErrorRefType,
        searchMode: state.search.searchMode,
        searchGeneralError: state.search.searchGeneralError,
        showSearchOptions: state.search.showSearchOptions,
        emailsError: state.search.emailsError,
        searchOptions: state.search.searchOptions,
        showModal: state.search.showModal,
        addEmail: state.search.addEmail,
        emails: state.search.emails    

['comments',
        {
            searchOptionType: 'comments',
            validationFunction: validationUtils.validateAddEmailComments,
            errorValidationText: translate.add_email_modal_error_invalid_comments,
            maximumCharactersCount: 300,
            maximumCharactersErrorText: translate.add_email_modal_error_comments_length_exceeds
        }
    ]

validateEmail
validateUrl
validateAddEmailComments
validateSearchKey

export const SEARCH_ADD_EMAIL_COMMENTS_PROCESS_START = 'SEARCH_ADD_EMAIL_COMMENTS_PROCESS_START';
export const SEARCH_ADD_EMAIL_COMMENTS_PROCESS_PREPARATION = 'SEARCH_ADD_EMAIL_COMMENTS_PROCESS_PREPARATION';
export const SEARCH_ADD_EMAIL_COMMENTS_PROCESS_ERROR = 'SEARCH_ADD_EMAIL_COMMENTS_PROCESS_ERROR';
export const SEARCH_ADD_EMAIL_COMMENTS_PROCESS_SUCCESS = 'SEARCH_ADD_EMAIL_COMMENTS_PROCESS_SUCCESS';

addEmailComments
emailComments 


   if (!action.emailId || action.emails || actions.emails.length === 0) {

// This action called when the user add the email successfully to his 
// emails list and to close the window after save the email to his emails list
export const onSearchAddEmailModalToggleSuccess = (state, action) => {
    return updateObject(state, {
        showModal: action.showModal,
        addEmail: action.addEmail
    });
};

// This action is called when the user clicks on the email side icon to add email to his emails list.
export const onSearchAddEmailModalToggleStart = (addEmailData) => {
    return {
        type: actionTypes.SEARCH_ADD_EMAIL_MODAL_TOGGLE_START,
        addEmailData: addEmailData
    };
};

// This action called when the user add the email successfully to his 
// emails list and to close the window after save the email to his emails list
export const onSearchAddEmailModalToggleSuccess = () => {
    return {
        type: actionTypes.SEARCH_ADD_EMAIL_MODAL_TOGGLE_SUCCESS
    };
};


export const SEARCH_MODAL_TOGGLE_SUCCESS = 'SEARCH_MODAL_TOGGLE_SUCCESS';
export const SEARCH_Add_EMAIL_MODAL_TOGGLE_START = 'SEARCH_Add_EMAIL_MODAL_TOGGLE_START';
export const SEARCH_Add_EMAIL_MODAL_TOGGLE_SUCCESS = 'SEARCH_Add_EMAIL_MODAL_TOGGLE_SUCCESS';
export const SEARCH_ADD_EMAIL_COMMENTS_CHANGE_SUCCESS = 'SEARCH_ADD_EMAIL_COMMENTS_CHANGE_SUCCESS';

// This action is called when the modal needs to be raised up 
// or closed (When user add email, or close the auth modal, for example).
export const onSearchModalToggleSuccess = (toggleModalData) => {
    return {
        type: actionTypes.SEARCH_MODAL_TOGGLE_SUCCESS,
        toggleModalData: toggleModalData
    };
};

// This action is called when the user enters input on the add email comments modal window
// to update the state when the key changes.
export const onSearchAddEmailCommentsChangeSuccess = (emailComments) => {
    return {
        type: actionTypes.SEARCH_ADD_EMAIL_COMMENTS_CHANGE_SUCCESS,
        emailComments: emailComments
    };
};

export const SEARCH_MODAL_TOGGLE_SUCCESS = 'SEARCH_MODAL_TOGGLE_SUCCESS';
export const SEARCH_ADD_EMAIL_KEY_CHANGE_SUCCESS = 'SEARCH_ADD_EMAIL_KEY_CHANGE_SUCCESS';

toggleAddEmailModalHandler
manageAddEmail
showAddEmailModal

const initialState = {
    isLoadingEmails: true,
    searchKeyTempValue: '',
    searchKeyInputValue: '',
    searchKeyErrorMessage: null,
    searchErrorRefType: null,
    searchMode: searchMode.TEXT,
    searchGeneralError: null,
    showSearchOptions: false,
    emailsError: false,
    searchOptions: [{
            searchOptionType: searchOptionType.DOMAINS,
            show: true,
            mode: searchOption.INCLUDE,
            value: '',
            error: null
        },
        {
            searchOptionType: searchOptionType.KEYS,
            show: true,
            mode: searchOption.INCLUDE,
            value: '',
            error: null
        },
        {
            searchOptionType: searchOptionType.URLS,
            show: true,
            mode: searchOption.INCLUDE,
            value: '',
            error: null
        }
    ],
    emails: null
};

 // Validate request parameters existence.
    // If any of the basic parameters are missing - Something went wrong - Show to the user general error.
    if (!action || /* !action.userId || !action.userToken || */ !action.searchMode || !action.searchKey) {
        searchRequestData.errorMessage = translate.error_missing.replace('#params#', 
        getErrorParametersString(['searchData', 'userId', 'userToken', 'searchMode', 'searchKey']));
    }

scrollMobileRefs
searchOptionsRefs

searchOptionsData = {
    searchOptions,
    searchOptionsToUpdate (searchOptionType, errorMessage)
    propertyName
};


const searchOptionsData = {
    searchOptions,
    currentSearchOptionType,
    propertyName,
    newValue
};



emailsData.emailsCount
noEmails

New: searchKeyTempValue
Old: searchKeyValue

-------------------
New:
searchKeyErrorMessage
Old:
searchOptionErrorMessage


SEARCH_SEARCH_KEY_CHANGE_SUCCESS

// This saga handles the login / registration process.
export function* authProcessStartSaga(action) {
    // Create the data to validate and to send an API request.
    const authDataRequest = {
        authMode: action.authMode,
        emailText: action.emailText,
        passwordText: action.passwordText
    };

    // Validate the email and the password parameters before any call to the API (client side validation).
    // If empty result - there was a general error not related to the validation, just return.
    const validationResult = yield call(validateAuthProcessSaga, authDataRequest);
    if (!validationResult) {
        return;
    }

    // If the validation failed to pass, generate the error of the problematic textbox.
    if (!validationResult.isValid) {
        yield put(actions.onAuthProcessValidationError(validationResult));
        return;
    }   

 if (action.newSearchMode === action.currentSearchMode) {
        return;
    }

    if (action.searchOptionData.searchOptions && action.searchOptionData.properyName === 'mode') {
        // Find the advance search option.
        const searchOptionItem = action.searchOptionData.searchOptions.find(srcOption => srcOption.searchOptionType === action.searchOptionData.currentSearchOptionType);
        // Check if they are the same. If so - Don't continue the process.
        if (searchOptionItem[action.searchOptionData.properyName] === action.searchOptionData.newValue) {
            return;
        }
    }


onSearchAdvancedOptionsToggleSuccess

export const SEARCH_ADVANCED_OPTIONS_TOGGLE_START = 'SEARCH_ADVANCED_OPTIONS_TOGGLE_START';
export const SEARCH_ADVANCED_OPTIONS_TOGGLE_SUCCESS = 'SEARCH_ADVANCED_OPTIONS_TOGGLE_SUCCESS';


export const SEARCH_MODE_CHANGE_START = 'SEARCH_MODE_CHANGE_START';
export const SEARCH_MODE_CHANGE_SUCCESS = 'SEARCH_MODE_CHANGE_SUCCESS';

search_advance_options_general_error    

searchGeneralError: PropTypes.string,
    searchOptionErrorMessage: PropTypes.string,

searchGeneralError={state.searchGeneralError}
searchOptionErrorMessage={state.searchOptionErrorMessage}

searchError
searchErrorMessage

propertyName,
currentSearchOptionType: 
newValue

ADVANCED_OPTION_CHANGE_START
ADVANCED_OPTION_CHANGE_SUCCESS


authentication_page_title
authentication_page_register_title

authentication_page_login_title
authentication_page_register_title

authentication_form_login_title
authentication_form_register_title


validateRegistrationAuthMode
validateLoginAuthMode

SearchBar.propTypes = {
    searchMode: PropTypes.string.isRequired,
    showSearchOptions: PropTypes.bool.isRequired,
    searchErrorMessage: PropTypes.string,
    searchOptions: PropTypes.arrayOf(
        PropTypes.shape({
            searchOptionType: PropTypes.string.isRequired,
            mode: PropTypes.string
        }).isRequired
    ).isRequired,
    onToggleSearchOptions: PropTypes.func.isRequired,
    onSearchClick: PropTypes.func.isRequired,
    onSearchChange: PropTypes.func.isRequired,
    onSearchOptionChange: PropTypes.func.isRequired,
    onSearchSelectChange: PropTypes.func.isRequired
};

isUserAuthenticated   

 isAuthenticated: isUserAuthenticated(state.auth.token)

export const AUTH_INPUT_CHANGE_START = 'AUTH_INPUT_CHANGE_START';
export const AUTH_INPUT_CHANGE_SUCCESS = 'AUTH_INPUT_CHANGE_SUCCESS';
export const AUTH_MODE_CHANGE_START = 'AUTH_MODE_CHANGE_START';
export const AUTH_MODE_CHANGE_SUCCESS = 'AUTH_MODE_CHANGE_SUCCESS';
export const AUTH_PROCESS_START = 'AUTH_PROCESS_START';
export const AUTH_PROCESS_PREPARATION = 'AUTH_PROCESS_PREPARATION';
export const AUTH_PROCESS_VALIDATION_ERROR = 'AUTH_PROCESS_VALIDATION_ERROR';
export const AUTH_PROCESS_SUCCESS = 'AUTH_PROCESS_SUCCESS';
export const AUTH_PROCESS_FAIL = 'AUTH_PROCESS_FAIL';
export const AUTH_CHECK_STATE = 'AUTH_CHECK_STATE';
export const AUTH_CHECK_TIMEOUT = 'AUTH_CHECK_TIMEOUT';
export const AUTH_LOGOUT_START = 'AUTH_LOGOUT_START';
export const AUTH_LOGOUT_SUCCESS = 'AUTH_LOGOUT_SUCCESS';    


"authentication_page_error_empty_email": "Please enter your email address",
    "authentication_page_error_email_length_exceeds": "Email address exceeds the maximum length of #count# characters",
    "authentication_page_error_email_length_under": "Email address under the minimum length of #count# characters",
    "authentication_page_error_email_invalid": "Invalid email address",
    "authentication_page_error_empty_password": "Please enter your password",
    "authentication_page_error_password_length_exceeds": "Password exceeds the maximum length of #count# characters",
    "authentication_page_error_password_length_under": "Password is under the minimum length of #count# characters",
    "authentication_page_error_invalid_password": "Password must include: 1 lowercase, 1 uppercase, 1 number, 1 special character",
    "authentication_page_error_auth_incorrect": "Username or password are incorrect, please try again",
    "authentication_page_error_email_exists": "Email already exists in the system",
    "authentication_page_error_general": "Oops... something went wrong :(",

[Idea] Change the prizes of win battle

Instead of getting 20-35 gold each victory (depend on your trophies level), you will get random prizes (20 prizes each day):
20-35 gold, 2 gems, 1 common trade token, 1 rare trade token (5% chance), 1 epic trade token (0.5% chance), 1 legendary trade token (0.005% chance).      


  const authData = {
            authMode: props.authMode,
            emailText: props.emailText,
            passwordText: props.passwordText
        };

/* https://www.googleapis.com/identitytoolkit/v3/relyingparty/${method}?key=${key} */

footer_logout_label
header_logout_label

searchClick *
searchChange *
searchOptionChange *
searchSelectChange *
toggleSearchOptions *
cancelClick *
authClick *
addClick *
commentsChange *
okClick *
counterChange *
deleteClick *
------------------


        toggleClass: generateClassName(!props.initSearchBar, props.showSearchOptions ? 'down' : 'up', 'hide-slideup'),
        searchBarClass = generateClassName(props.searchErrorMessage, 'search-bar', 'error'),
        selectedSearchOptionType = (currentSearchOptionType) => {
            return searchOptionsData.find((src) => src.searchOptionType === currentSearchOptionType);
        },
        searchOptionsData: [
            {
                searchOptionType: searchOptionType.DOMAINS,
                title: translate.search_bar_email_domains_title,
                descriptionText: translate.search_bar_email_domains_description,
                exampleText: translate.search_bar_email_domains_example
            },
            {
                searchOptionType: searchOptionType.KEYS,
                title: translate.search_bar_email_keys_title,
                descriptionText: translate.search_bar_email_keys_description,
                exampleText: translate.search_bar_email_keys_example
            },
            {
                searchOptionType: searchOptionType.URLS,
                title: translate.search_bar_urls_title,
                descriptionText: translate.search_bar_urls_description,
                exampleText: translate.search_bar_urls_example
            }
        ]
    }




valid:



Invalid:


Unknown
#!$%&'*+-/=?^_`{}|~@example.org
"()[]:,;@\\\"!#$%&'*+-/=?^_`{}| ~.a"@example.org
" "@example.org (space between the quotes)
üñîçøðé@example.com
üñîçøðé@üñîçøðé.com
Pelé@example.com
δοκιμή@παράδειγμα.δοκιμή
我買@屋企.香港
甲斐@黒川.日本
чебурашка@ящик-с-апельсинами.рф




 "authentication_page_error_empty_email": "Please enter your email address",
    "authentication_page_error_email_length_exceeds": "Email address exceeds the maximum length of #count# characters",
    "authentication_page_error_email_length_under": "Email address under the minimum length of #count# characters",
    "authentication_page_error_email_invalid": "Invalid email address",
    "authentication_page_error_empty_password": "Please enter your password",
    "authentication_page_error_password_length_exceeds": "Password exceeds the maximum length of #count# characters",
    "authentication_page_error_password_length_under": "Password is under the minimum length of #count# characters",
    "authentication_page_error_invalid_password": "Password must include at least 1 lowercase letter [a-z], 1 uppercase letter [A-Z], 1 number [0-9] and 1 special character"
    "authentication_page_error_auth_incorrect": "Username or password are incorrect, please try again",
-------------------------------
NEW          
  emailsCountPerPage: 10,
            totalEmailsCount: null,
            currentPageNumber: 1,
            totalPagesCount: null

-------------------------------
OLD
        emailsNavigation: {
            emailsPerPage: 10,
            totalEmails: null,
            currentPageNumber: 1,
            totalPages: null
        },
    show: PropTypes.bool.isRequired,
    emailsPerPage: PropTypes.number.isRequired,
    totalCount: PropTypes.number.isRequired,
    counterChange: PropTypes.func
                                emailsPerPage={props.emailsPerPage}
                                totalCount={props.emails.length}
-------------------------------


"delete_email_modal_title": "Delete confirmation",
    "delete_email_modal_text": "Are you sure you want to delete",
    "delete_email_modal_cancel_button": "Cancel",
    "delete_email_modal_ok_button": "Delete"

emails_page_main_title
emails_page_emails_count
  

  "emails_limit_modal_title": "Emails limit exceeded",
    "emails_limit_modal_text": "Your emails storage limit exceeded the maximum emails users can save (200). In order to save new emails, go to My emails page and remove old emails",
    "emails_limit_modal_ok_button": "Ok"
emails_limit_modal_image_alt_title

The text entered exceeds the maximum length

add_email_modal_error_invalid_comments
add_email_modal_error_comments_length_exceeds

1800335166

    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    max-width: 77.5%;

export const validateEmailDomains = (value) => {
    return baseValidateMultiValues(value, baseValidateEmailDomain);
};

export const validateEmailKeys = (value) => {
    return baseValidateMultiValues(value, baseValidateEmailKey);
};

export const validateUrlDomains = (value) => {
    return baseValidateMultiValues(value, validateUrl);
};  


  "search_bar_email_domains_invalid_input": "Invalid email domain: #invalid#",
    "search_bar_email_domains_error_length_exceeds": "Email domains length exceeds #count# characters",
    "search_bar_email_keys_invalid_input": "Invalid email key: #invalid#",
    "search_bar_email_keys_error_length_exceeds": "Email keys length exceeds #count# characters",
    "search_bar_url_domains_invalid_input": "Invalid url domain: #invalid#",
    "search_bar_url_domains_error_length_exceeds": "Url domains length exceeds #count# characters",
    

"search_bar_search_key_error_length_exceeds": "Search key length exceeds #count# characters",
    "search_bar_url_error_length_exceeds": "Search key length exceeds #count# characters",

search_bar_error_url

isDifferentColor

generateClassName
import { generateClassName } from '../../../utils/textUtils';

rgb(185,217,249)

npm i axios redux react-redux redux-saga prop-types react-router react-router-dom enzyme enzyme-adapter-react-16 react-test-renderer eslint-plugin-react

serviceeahr@ecp.co.il

    -webkit-transition: all 300ms linear;
    -moz-transition: all 300ms linear;
    -o-transition: all 300ms linear;
    -ms-transition: all 300ms linear;
    transition: all 300ms linear;

border-radius
box-sizing
transition
transform
box-shadow
animation-duration
animation-delay
animation-name
font-smoothing

    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;

  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;

    -webkit-animation: fadeIn 2s;
    -moz-animation: fadeIn 2s;
    -ms-animation: fadeIn 2s;
    -o-animation: fadeIn 2s;
    animation: fadeIn 2s;